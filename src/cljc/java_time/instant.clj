(ns cljc.java-time.instant (:refer-clojure :exclude [get range format min max next name resolve]) (:import [java.time Instant]))
(def min (. java.time.Instant -MIN))
(def epoch (. java.time.Instant -EPOCH))
(def max (. java.time.Instant -MAX))
(clojure.core/defn truncated-to {:arglists (quote (["java.time.Instant" "java.time.temporal.TemporalUnit"]))} (^java.time.Instant [^java.time.Instant this6678 ^java.time.temporal.TemporalUnit java-time-temporal-TemporalUnit6679] (.truncatedTo this6678 java-time-temporal-TemporalUnit6679)))
(clojure.core/defn range {:arglists (quote (["java.time.Instant" "java.time.temporal.TemporalField"]))} (^java.time.temporal.ValueRange [^java.time.Instant this6680 ^java.time.temporal.TemporalField java-time-temporal-TemporalField6681] (.range this6680 java-time-temporal-TemporalField6681)))
(clojure.core/defn of-epoch-second {:arglists (quote (["long" "long"] ["long"]))} (^java.time.Instant [^long long6682 ^long long6683] (. java.time.Instant ofEpochSecond long6682 long6683)) (^java.time.Instant [^long long6684] (. java.time.Instant ofEpochSecond long6684)))
(clojure.core/defn at-offset {:arglists (quote (["java.time.Instant" "java.time.ZoneOffset"]))} (^java.time.OffsetDateTime [^java.time.Instant this6685 ^java.time.ZoneOffset java-time-ZoneOffset6686] (.atOffset this6685 java-time-ZoneOffset6686)))
(clojure.core/defn minus-millis {:arglists (quote (["java.time.Instant" "long"]))} (^java.time.Instant [^java.time.Instant this6687 ^long long6688] (.minusMillis this6687 long6688)))
(clojure.core/defn get-nano {:arglists (quote (["java.time.Instant"]))} (^java.lang.Integer [^java.time.Instant this6689] (.getNano this6689)))
(clojure.core/defn plus-millis {:arglists (quote (["java.time.Instant" "long"]))} (^java.time.Instant [^java.time.Instant this6690 ^long long6691] (.plusMillis this6690 long6691)))
(clojure.core/defn minus-seconds {:arglists (quote (["java.time.Instant" "long"]))} (^java.time.Instant [^java.time.Instant this6692 ^long long6693] (.minusSeconds this6692 long6693)))
(clojure.core/defn plus-nanos {:arglists (quote (["java.time.Instant" "long"]))} (^java.time.Instant [^java.time.Instant this6694 ^long long6695] (.plusNanos this6694 long6695)))
(clojure.core/defn plus {:arglists (quote (["java.time.Instant" "long" "java.time.temporal.TemporalUnit"] ["java.time.Instant" "long" "java.time.temporal.TemporalUnit"] ["java.time.Instant" "java.time.temporal.TemporalAmount"] ["java.time.Instant" "java.time.temporal.TemporalAmount"]))} (^java.lang.Object [this6696 G__6697 G__6698] (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.lang.Long") G__6697) (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalUnit") G__6698)) (clojure.core/let [G__6697 (clojure.core/long G__6697) G__6698 ^"java.time.temporal.TemporalUnit" G__6698] (.plus ^java.time.Instant this6696 G__6697 G__6698)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.lang.Long") G__6697) (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalUnit") G__6698)) (clojure.core/let [G__6697 (clojure.core/long G__6697) G__6698 ^"java.time.temporal.TemporalUnit" G__6698] (.plus ^java.time.Instant this6696 G__6697 G__6698)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args")))) (^java.lang.Object [this6699 G__6700] (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalAmount") G__6700)) (clojure.core/let [G__6700 ^"java.time.temporal.TemporalAmount" G__6700] (.plus ^java.time.Instant this6699 G__6700)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalAmount") G__6700)) (clojure.core/let [G__6700 ^"java.time.temporal.TemporalAmount" G__6700] (.plus ^java.time.Instant this6699 G__6700)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args")))))
(clojure.core/defn query {:arglists (quote (["java.time.Instant" "java.time.temporal.TemporalQuery"]))} (^java.lang.Object [^java.time.Instant this6701 ^java.time.temporal.TemporalQuery java-time-temporal-TemporalQuery6702] (.query this6701 java-time-temporal-TemporalQuery6702)))
(clojure.core/defn to-string {:arglists (quote (["java.time.Instant"]))} (^java.lang.String [^java.time.Instant this6703] (.toString this6703)))
(clojure.core/defn is-before {:arglists (quote (["java.time.Instant" "java.time.Instant"]))} (^java.lang.Boolean [^java.time.Instant this6704 ^java.time.Instant java-time-Instant6705] (.isBefore this6704 java-time-Instant6705)))
(clojure.core/defn minus {:arglists (quote (["java.time.Instant" "long" "java.time.temporal.TemporalUnit"] ["java.time.Instant" "java.time.temporal.TemporalAmount"] ["java.time.Instant" "long" "java.time.temporal.TemporalUnit"] ["java.time.Instant" "java.time.temporal.TemporalAmount"]))} (^java.lang.Object [this6706 G__6707 G__6708] (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.lang.Long") G__6707) (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalUnit") G__6708)) (clojure.core/let [G__6707 (clojure.core/long G__6707) G__6708 ^"java.time.temporal.TemporalUnit" G__6708] (.minus ^java.time.Instant this6706 G__6707 G__6708)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.lang.Long") G__6707) (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalUnit") G__6708)) (clojure.core/let [G__6707 (clojure.core/long G__6707) G__6708 ^"java.time.temporal.TemporalUnit" G__6708] (.minus ^java.time.Instant this6706 G__6707 G__6708)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args")))) (^java.lang.Object [this6709 G__6710] (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalAmount") G__6710)) (clojure.core/let [G__6710 ^"java.time.temporal.TemporalAmount" G__6710] (.minus ^java.time.Instant this6709 G__6710)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalAmount") G__6710)) (clojure.core/let [G__6710 ^"java.time.temporal.TemporalAmount" G__6710] (.minus ^java.time.Instant this6709 G__6710)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args")))))
(clojure.core/defn at-zone {:arglists (quote (["java.time.Instant" "java.time.ZoneId"]))} (^java.time.ZonedDateTime [^java.time.Instant this6711 ^java.time.ZoneId java-time-ZoneId6712] (.atZone this6711 java-time-ZoneId6712)))
(clojure.core/defn of-epoch-milli {:arglists (quote (["long"]))} (^java.time.Instant [^long long6713] (. java.time.Instant ofEpochMilli long6713)))
(clojure.core/defn get-long {:arglists (quote (["java.time.Instant" "java.time.temporal.TemporalField"]))} (^long [^java.time.Instant this6714 ^java.time.temporal.TemporalField java-time-temporal-TemporalField6715] (.getLong this6714 java-time-temporal-TemporalField6715)))
(clojure.core/defn until {:arglists (quote (["java.time.Instant" "java.time.temporal.Temporal" "java.time.temporal.TemporalUnit"]))} (^long [^java.time.Instant this6716 ^java.time.temporal.Temporal java-time-temporal-Temporal6717 ^java.time.temporal.TemporalUnit java-time-temporal-TemporalUnit6718] (.until this6716 java-time-temporal-Temporal6717 java-time-temporal-TemporalUnit6718)))
(clojure.core/defn from {:arglists (quote (["java.time.temporal.TemporalAccessor"]))} (^java.time.Instant [^java.time.temporal.TemporalAccessor java-time-temporal-TemporalAccessor6719] (. java.time.Instant from java-time-temporal-TemporalAccessor6719)))
(clojure.core/defn is-after {:arglists (quote (["java.time.Instant" "java.time.Instant"]))} (^java.lang.Boolean [^java.time.Instant this6720 ^java.time.Instant java-time-Instant6721] (.isAfter this6720 java-time-Instant6721)))
(clojure.core/defn minus-nanos {:arglists (quote (["java.time.Instant" "long"]))} (^java.time.Instant [^java.time.Instant this6722 ^long long6723] (.minusNanos this6722 long6723)))
(clojure.core/defn is-supported {:arglists (quote (["java.time.Instant" "java.time.temporal.TemporalUnit"] ["java.time.Instant" "java.time.temporal.TemporalField"]))} (^java.lang.Boolean [this6724 G__6725] (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalUnit") G__6725)) (clojure.core/let [G__6725 ^"java.time.temporal.TemporalUnit" G__6725] (.isSupported ^java.time.Instant this6724 G__6725)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalField") G__6725)) (clojure.core/let [G__6725 ^"java.time.temporal.TemporalField" G__6725] (.isSupported ^java.time.Instant this6724 G__6725)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args")))))
(clojure.core/defn parse {:arglists (quote (["java.lang.CharSequence"]))} (^java.time.Instant [^java.lang.CharSequence java-lang-CharSequence6726] (. java.time.Instant parse java-lang-CharSequence6726)))
(clojure.core/defn hash-code {:arglists (quote (["java.time.Instant"]))} (^java.lang.Integer [^java.time.Instant this6727] (.hashCode this6727)))
(clojure.core/defn adjust-into {:arglists (quote (["java.time.Instant" "java.time.temporal.Temporal"]))} (^java.time.temporal.Temporal [^java.time.Instant this6728 ^java.time.temporal.Temporal java-time-temporal-Temporal6729] (.adjustInto this6728 java-time-temporal-Temporal6729)))
(clojure.core/defn with {:arglists (quote (["java.time.Instant" "java.time.temporal.TemporalAdjuster"] ["java.time.Instant" "java.time.temporal.TemporalField" "long"] ["java.time.Instant" "java.time.temporal.TemporalField" "long"] ["java.time.Instant" "java.time.temporal.TemporalAdjuster"]))} (^java.lang.Object [this6730 G__6731] (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalAdjuster") G__6731)) (clojure.core/let [G__6731 ^"java.time.temporal.TemporalAdjuster" G__6731] (.with ^java.time.Instant this6730 G__6731)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalAdjuster") G__6731)) (clojure.core/let [G__6731 ^"java.time.temporal.TemporalAdjuster" G__6731] (.with ^java.time.Instant this6730 G__6731)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args")))) (^java.lang.Object [this6732 G__6733 G__6734] (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalField") G__6733) (clojure.core/instance? (java.lang.Class/forName "java.lang.Long") G__6734)) (clojure.core/let [G__6733 ^"java.time.temporal.TemporalField" G__6733 G__6734 (clojure.core/long G__6734)] (.with ^java.time.Instant this6732 G__6733 G__6734)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalField") G__6733) (clojure.core/instance? (java.lang.Class/forName "java.lang.Long") G__6734)) (clojure.core/let [G__6733 ^"java.time.temporal.TemporalField" G__6733 G__6734 (clojure.core/long G__6734)] (.with ^java.time.Instant this6732 G__6733 G__6734)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args")))))
(clojure.core/defn now {:arglists (quote ([] ["java.time.Clock"]))} (^java.time.Instant [] (. java.time.Instant now)) (^java.time.Instant [^java.time.Clock java-time-Clock6735] (. java.time.Instant now java-time-Clock6735)))
(clojure.core/defn to-epoch-milli {:arglists (quote (["java.time.Instant"]))} (^long [^java.time.Instant this6736] (.toEpochMilli this6736)))
(clojure.core/defn get-epoch-second {:arglists (quote (["java.time.Instant"]))} (^long [^java.time.Instant this6737] (.getEpochSecond this6737)))
(clojure.core/defn compare-to {:arglists (quote (["java.time.Instant" "java.lang.Object"] ["java.time.Instant" "java.time.Instant"]))} (^java.lang.Integer [this6738 G__6739] (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.lang.Object") G__6739)) (clojure.core/let [G__6739 ^"java.lang.Object" G__6739] (.compareTo ^java.time.Instant this6738 G__6739)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.Instant") G__6739)) (clojure.core/let [G__6739 ^"java.time.Instant" G__6739] (.compareTo ^java.time.Instant this6738 G__6739)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args")))))
(clojure.core/defn plus-seconds {:arglists (quote (["java.time.Instant" "long"]))} (^java.time.Instant [^java.time.Instant this6740 ^long long6741] (.plusSeconds this6740 long6741)))
(clojure.core/defn get {:arglists (quote (["java.time.Instant" "java.time.temporal.TemporalField"]))} (^java.lang.Integer [^java.time.Instant this6742 ^java.time.temporal.TemporalField java-time-temporal-TemporalField6743] (.get this6742 java-time-temporal-TemporalField6743)))
(clojure.core/defn equals {:arglists (quote (["java.time.Instant" "java.lang.Object"]))} (^java.lang.Boolean [^java.time.Instant this6744 ^java.lang.Object java-lang-Object6745] (.equals this6744 java-lang-Object6745)))
