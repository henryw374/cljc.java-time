(ns cljc.java-time.offset-time (:refer-clojure :exclude [get range format min max next name resolve short]) (:require [cljc.java-time.extn.calendar-awareness]) (:import [java.time OffsetTime]))
(def min java.time.OffsetTime/MIN)
(def max java.time.OffsetTime/MAX)
(clojure.core/defn minus-minutes {:arglists (quote (["java.time.OffsetTime" "long"]))} (^java.time.OffsetTime [^java.time.OffsetTime this6972 ^long long6973] (.minusMinutes this6972 long6973)))
(clojure.core/defn truncated-to {:arglists (quote (["java.time.OffsetTime" "java.time.temporal.TemporalUnit"]))} (^java.time.OffsetTime [^java.time.OffsetTime this6974 ^java.time.temporal.TemporalUnit java-time-temporal-TemporalUnit6975] (.truncatedTo this6974 java-time-temporal-TemporalUnit6975)))
(clojure.core/defn range {:arglists (quote (["java.time.OffsetTime" "java.time.temporal.TemporalField"]))} (^java.time.temporal.ValueRange [^java.time.OffsetTime this6976 ^java.time.temporal.TemporalField java-time-temporal-TemporalField6977] (.range this6976 java-time-temporal-TemporalField6977)))
(clojure.core/defn get-hour {:arglists (quote (["java.time.OffsetTime"]))} (^java.lang.Integer [^java.time.OffsetTime this6978] (.getHour this6978)))
(clojure.core/defn minus-hours {:arglists (quote (["java.time.OffsetTime" "long"]))} (^java.time.OffsetTime [^java.time.OffsetTime this6979 ^long long6980] (.minusHours this6979 long6980)))
(clojure.core/defn of {:arglists (quote (["int" "int" "int" "int" "java.time.ZoneOffset"] ["java.time.LocalTime" "java.time.ZoneOffset"]))} (^java.time.OffsetTime [^java.lang.Integer int6981 ^java.lang.Integer int6982 ^java.lang.Integer int6983 ^java.lang.Integer int6984 ^java.time.ZoneOffset java-time-ZoneOffset6985] (java.time.OffsetTime/of int6981 int6982 int6983 int6984 java-time-ZoneOffset6985)) (^java.time.OffsetTime [^java.time.LocalTime java-time-LocalTime6986 ^java.time.ZoneOffset java-time-ZoneOffset6987] (java.time.OffsetTime/of java-time-LocalTime6986 java-time-ZoneOffset6987)))
(clojure.core/defn is-equal {:arglists (quote (["java.time.OffsetTime" "java.time.OffsetTime"]))} (^java.lang.Boolean [^java.time.OffsetTime this6988 ^java.time.OffsetTime java-time-OffsetTime6989] (.isEqual this6988 java-time-OffsetTime6989)))
(clojure.core/defn get-nano {:arglists (quote (["java.time.OffsetTime"]))} (^java.lang.Integer [^java.time.OffsetTime this6990] (.getNano this6990)))
(clojure.core/defn minus-seconds {:arglists (quote (["java.time.OffsetTime" "long"]))} (^java.time.OffsetTime [^java.time.OffsetTime this6991 ^long long6992] (.minusSeconds this6991 long6992)))
(clojure.core/defn get-second {:arglists (quote (["java.time.OffsetTime"]))} (^java.lang.Integer [^java.time.OffsetTime this6993] (.getSecond this6993)))
(clojure.core/defn plus-nanos {:arglists (quote (["java.time.OffsetTime" "long"]))} (^java.time.OffsetTime [^java.time.OffsetTime this6994 ^long long6995] (.plusNanos this6994 long6995)))
(clojure.core/defn plus {:arglists (quote (["java.time.OffsetTime" "long" "java.time.temporal.TemporalUnit"] ["java.time.OffsetTime" "long" "java.time.temporal.TemporalUnit"] ["java.time.OffsetTime" "java.time.temporal.TemporalAmount"] ["java.time.OffsetTime" "java.time.temporal.TemporalAmount"]))} (^java.lang.Object [this6996 G__6997 G__6998] (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.lang.Long") G__6997) (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalUnit") G__6998)) (clojure.core/let [G__6997 (clojure.core/long G__6997) G__6998 ^"java.time.temporal.TemporalUnit" G__6998] (.plus ^java.time.OffsetTime this6996 G__6997 G__6998)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.lang.Long") G__6997) (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalUnit") G__6998)) (clojure.core/let [G__6997 (clojure.core/long G__6997) G__6998 ^"java.time.temporal.TemporalUnit" G__6998] (.plus ^java.time.OffsetTime this6996 G__6997 G__6998)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args")))) (^java.lang.Object [this6999 G__7000] (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalAmount") G__7000)) (clojure.core/let [G__7000 ^"java.time.temporal.TemporalAmount" G__7000] (.plus ^java.time.OffsetTime this6999 G__7000)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalAmount") G__7000)) (clojure.core/let [G__7000 ^"java.time.temporal.TemporalAmount" G__7000] (.plus ^java.time.OffsetTime this6999 G__7000)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args")))))
(clojure.core/defn with-hour {:arglists (quote (["java.time.OffsetTime" "int"]))} (^java.time.OffsetTime [^java.time.OffsetTime this7001 ^java.lang.Integer int7002] (.withHour this7001 int7002)))
(clojure.core/defn with-minute {:arglists (quote (["java.time.OffsetTime" "int"]))} (^java.time.OffsetTime [^java.time.OffsetTime this7003 ^java.lang.Integer int7004] (.withMinute this7003 int7004)))
(clojure.core/defn plus-minutes {:arglists (quote (["java.time.OffsetTime" "long"]))} (^java.time.OffsetTime [^java.time.OffsetTime this7005 ^long long7006] (.plusMinutes this7005 long7006)))
(clojure.core/defn query {:arglists (quote (["java.time.OffsetTime" "java.time.temporal.TemporalQuery"]))} (^java.lang.Object [^java.time.OffsetTime this7007 ^java.time.temporal.TemporalQuery java-time-temporal-TemporalQuery7008] (.query this7007 java-time-temporal-TemporalQuery7008)))
(clojure.core/defn at-date {:arglists (quote (["java.time.OffsetTime" "java.time.LocalDate"]))} (^java.time.OffsetDateTime [^java.time.OffsetTime this7009 ^java.time.LocalDate java-time-LocalDate7010] (.atDate this7009 java-time-LocalDate7010)))
(clojure.core/defn with-offset-same-instant {:arglists (quote (["java.time.OffsetTime" "java.time.ZoneOffset"]))} (^java.time.OffsetTime [^java.time.OffsetTime this7011 ^java.time.ZoneOffset java-time-ZoneOffset7012] (.withOffsetSameInstant this7011 java-time-ZoneOffset7012)))
(clojure.core/defn to-string {:arglists (quote (["java.time.OffsetTime"]))} (^java.lang.String [^java.time.OffsetTime this7013] (.toString this7013)))
(clojure.core/defn is-before {:arglists (quote (["java.time.OffsetTime" "java.time.OffsetTime"]))} (^java.lang.Boolean [^java.time.OffsetTime this7014 ^java.time.OffsetTime java-time-OffsetTime7015] (.isBefore this7014 java-time-OffsetTime7015)))
(clojure.core/defn minus {:arglists (quote (["java.time.OffsetTime" "java.time.temporal.TemporalAmount"] ["java.time.OffsetTime" "java.time.temporal.TemporalAmount"] ["java.time.OffsetTime" "long" "java.time.temporal.TemporalUnit"] ["java.time.OffsetTime" "long" "java.time.temporal.TemporalUnit"]))} (^java.lang.Object [this7016 G__7017] (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalAmount") G__7017)) (clojure.core/let [G__7017 ^"java.time.temporal.TemporalAmount" G__7017] (.minus ^java.time.OffsetTime this7016 G__7017)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalAmount") G__7017)) (clojure.core/let [G__7017 ^"java.time.temporal.TemporalAmount" G__7017] (.minus ^java.time.OffsetTime this7016 G__7017)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args")))) (^java.lang.Object [this7018 G__7019 G__7020] (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.lang.Long") G__7019) (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalUnit") G__7020)) (clojure.core/let [G__7019 (clojure.core/long G__7019) G__7020 ^"java.time.temporal.TemporalUnit" G__7020] (.minus ^java.time.OffsetTime this7018 G__7019 G__7020)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.lang.Long") G__7019) (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalUnit") G__7020)) (clojure.core/let [G__7019 (clojure.core/long G__7019) G__7020 ^"java.time.temporal.TemporalUnit" G__7020] (.minus ^java.time.OffsetTime this7018 G__7019 G__7020)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args")))))
(clojure.core/defn plus-hours {:arglists (quote (["java.time.OffsetTime" "long"]))} (^java.time.OffsetTime [^java.time.OffsetTime this7021 ^long long7022] (.plusHours this7021 long7022)))
(clojure.core/defn to-local-time {:arglists (quote (["java.time.OffsetTime"]))} (^java.time.LocalTime [^java.time.OffsetTime this7023] (.toLocalTime this7023)))
(clojure.core/defn get-long {:arglists (quote (["java.time.OffsetTime" "java.time.temporal.TemporalField"]))} (^long [^java.time.OffsetTime this7024 ^java.time.temporal.TemporalField java-time-temporal-TemporalField7025] (.getLong this7024 java-time-temporal-TemporalField7025)))
(clojure.core/defn get-offset {:arglists (quote (["java.time.OffsetTime"]))} (^java.time.ZoneOffset [^java.time.OffsetTime this7026] (.getOffset this7026)))
(clojure.core/defn with-nano {:arglists (quote (["java.time.OffsetTime" "int"]))} (^java.time.OffsetTime [^java.time.OffsetTime this7027 ^java.lang.Integer int7028] (.withNano this7027 int7028)))
(clojure.core/defn to-epoch-second {:arglists (quote (["java.time.OffsetTime" "java.time.LocalDate"]))} (^long [^java.time.OffsetTime this7029 ^java.time.LocalDate java-time-LocalDate7030] (.toEpochSecond this7029 java-time-LocalDate7030)))
(clojure.core/defn until {:arglists (quote (["java.time.OffsetTime" "java.time.temporal.Temporal" "java.time.temporal.TemporalUnit"]))} (^long [^java.time.OffsetTime this7031 ^java.time.temporal.Temporal java-time-temporal-Temporal7032 ^java.time.temporal.TemporalUnit java-time-temporal-TemporalUnit7033] (.until this7031 java-time-temporal-Temporal7032 java-time-temporal-TemporalUnit7033)))
(clojure.core/defn with-offset-same-local {:arglists (quote (["java.time.OffsetTime" "java.time.ZoneOffset"]))} (^java.time.OffsetTime [^java.time.OffsetTime this7034 ^java.time.ZoneOffset java-time-ZoneOffset7035] (.withOffsetSameLocal this7034 java-time-ZoneOffset7035)))
(clojure.core/defn from {:arglists (quote (["java.time.temporal.TemporalAccessor"]))} (^java.time.OffsetTime [^java.time.temporal.TemporalAccessor java-time-temporal-TemporalAccessor7036] (java.time.OffsetTime/from java-time-temporal-TemporalAccessor7036)))
(clojure.core/defn is-after {:arglists (quote (["java.time.OffsetTime" "java.time.OffsetTime"]))} (^java.lang.Boolean [^java.time.OffsetTime this7037 ^java.time.OffsetTime java-time-OffsetTime7038] (.isAfter this7037 java-time-OffsetTime7038)))
(clojure.core/defn minus-nanos {:arglists (quote (["java.time.OffsetTime" "long"]))} (^java.time.OffsetTime [^java.time.OffsetTime this7039 ^long long7040] (.minusNanos this7039 long7040)))
(clojure.core/defn is-supported {:arglists (quote (["java.time.OffsetTime" "java.time.temporal.TemporalUnit"] ["java.time.OffsetTime" "java.time.temporal.TemporalField"]))} (^java.lang.Boolean [this7041 G__7042] (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalUnit") G__7042)) (clojure.core/let [G__7042 ^"java.time.temporal.TemporalUnit" G__7042] (.isSupported ^java.time.OffsetTime this7041 G__7042)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalField") G__7042)) (clojure.core/let [G__7042 ^"java.time.temporal.TemporalField" G__7042] (.isSupported ^java.time.OffsetTime this7041 G__7042)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args")))))
(clojure.core/defn parse {:arglists (quote (["java.lang.CharSequence" "java.time.format.DateTimeFormatter"] ["java.lang.CharSequence"]))} (^java.time.OffsetTime [^java.lang.CharSequence java-lang-CharSequence7043 ^java.time.format.DateTimeFormatter java-time-format-DateTimeFormatter7044] (java.time.OffsetTime/parse java-lang-CharSequence7043 java-time-format-DateTimeFormatter7044)) (^java.time.OffsetTime [^java.lang.CharSequence java-lang-CharSequence7045] (java.time.OffsetTime/parse java-lang-CharSequence7045)))
(clojure.core/defn with-second {:arglists (quote (["java.time.OffsetTime" "int"]))} (^java.time.OffsetTime [^java.time.OffsetTime this7046 ^java.lang.Integer int7047] (.withSecond this7046 int7047)))
(clojure.core/defn get-minute {:arglists (quote (["java.time.OffsetTime"]))} (^java.lang.Integer [^java.time.OffsetTime this7048] (.getMinute this7048)))
(clojure.core/defn hash-code {:arglists (quote (["java.time.OffsetTime"]))} (^java.lang.Integer [^java.time.OffsetTime this7049] (.hashCode this7049)))
(clojure.core/defn adjust-into {:arglists (quote (["java.time.OffsetTime" "java.time.temporal.Temporal"]))} (^java.time.temporal.Temporal [^java.time.OffsetTime this7050 ^java.time.temporal.Temporal java-time-temporal-Temporal7051] (.adjustInto this7050 java-time-temporal-Temporal7051)))
(clojure.core/defn with {:arglists (quote (["java.time.OffsetTime" "java.time.temporal.TemporalField" "long"] ["java.time.OffsetTime" "java.time.temporal.TemporalField" "long"] ["java.time.OffsetTime" "java.time.temporal.TemporalAdjuster"] ["java.time.OffsetTime" "java.time.temporal.TemporalAdjuster"]))} (^java.lang.Object [this7052 G__7053 G__7054] (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalField") G__7053) (clojure.core/instance? (java.lang.Class/forName "java.lang.Long") G__7054)) (clojure.core/let [G__7053 ^"java.time.temporal.TemporalField" G__7053 G__7054 (clojure.core/long G__7054)] (.with ^java.time.OffsetTime this7052 G__7053 G__7054)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalField") G__7053) (clojure.core/instance? (java.lang.Class/forName "java.lang.Long") G__7054)) (clojure.core/let [G__7053 ^"java.time.temporal.TemporalField" G__7053 G__7054 (clojure.core/long G__7054)] (.with ^java.time.OffsetTime this7052 G__7053 G__7054)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args")))) (^java.lang.Object [this7055 G__7056] (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalAdjuster") G__7056)) (clojure.core/let [G__7056 ^"java.time.temporal.TemporalAdjuster" G__7056] (.with ^java.time.OffsetTime this7055 G__7056)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalAdjuster") G__7056)) (clojure.core/let [G__7056 ^"java.time.temporal.TemporalAdjuster" G__7056] (.with ^java.time.OffsetTime this7055 G__7056)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args")))))
(clojure.core/defn now {:arglists (quote (["java.time.ZoneId"] ["java.time.Clock"] []))} (^java.time.OffsetTime [G__7058] (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.ZoneId") G__7058)) (clojure.core/let [G__7058 ^"java.time.ZoneId" G__7058] (java.time.OffsetTime/now G__7058)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.Clock") G__7058)) (clojure.core/let [G__7058 ^"java.time.Clock" G__7058] (java.time.OffsetTime/now G__7058)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args")))) (^java.time.OffsetTime [] (java.time.OffsetTime/now)))
(clojure.core/defn compare-to {:arglists (quote (["java.time.OffsetTime" "java.lang.Object"] ["java.time.OffsetTime" "java.time.OffsetTime"]))} (^java.lang.Integer [this7059 G__7060] (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.lang.Object") G__7060)) (clojure.core/let [G__7060 ^"java.lang.Object" G__7060] (.compareTo ^java.time.OffsetTime this7059 G__7060)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.OffsetTime") G__7060)) (clojure.core/let [G__7060 ^"java.time.OffsetTime" G__7060] (.compareTo ^java.time.OffsetTime this7059 G__7060)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args")))))
(clojure.core/defn of-instant {:arglists (quote (["java.time.Instant" "java.time.ZoneId"]))} (^java.time.OffsetTime [^java.time.Instant java-time-Instant7061 ^java.time.ZoneId java-time-ZoneId7062] (java.time.OffsetTime/ofInstant java-time-Instant7061 java-time-ZoneId7062)))
(clojure.core/defn plus-seconds {:arglists (quote (["java.time.OffsetTime" "long"]))} (^java.time.OffsetTime [^java.time.OffsetTime this7063 ^long long7064] (.plusSeconds this7063 long7064)))
(clojure.core/defn get {:arglists (quote (["java.time.OffsetTime" "java.time.temporal.TemporalField"]))} (^java.lang.Integer [^java.time.OffsetTime this7065 ^java.time.temporal.TemporalField java-time-temporal-TemporalField7066] (.get this7065 java-time-temporal-TemporalField7066)))
(clojure.core/defn equals {:arglists (quote (["java.time.OffsetTime" "java.lang.Object"]))} (^java.lang.Boolean [^java.time.OffsetTime this7067 ^java.lang.Object java-lang-Object7068] (.equals this7067 java-lang-Object7068)))
(clojure.core/defn format {:arglists (quote (["java.time.OffsetTime" "java.time.format.DateTimeFormatter"]))} (^java.lang.String [^java.time.OffsetTime this7069 ^java.time.format.DateTimeFormatter java-time-format-DateTimeFormatter7070] (.format this7069 java-time-format-DateTimeFormatter7070)))
