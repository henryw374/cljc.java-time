(ns cljc.java-time.offset-time (:refer-clojure :exclude [get range format min max next name resolve short]) (:require [cljc.java-time.extn.calendar-awareness]) (:import [java.time OffsetTime]))
(def min java.time.OffsetTime/MIN)
(def max java.time.OffsetTime/MAX)
(clojure.core/defn minus-minutes {:arglists (quote (["java.time.OffsetTime" "long"]))} (^java.time.OffsetTime [^java.time.OffsetTime this6952 ^long long6953] (.minusMinutes this6952 long6953)))
(clojure.core/defn truncated-to {:arglists (quote (["java.time.OffsetTime" "java.time.temporal.TemporalUnit"]))} (^java.time.OffsetTime [^java.time.OffsetTime this6954 ^java.time.temporal.TemporalUnit java-time-temporal-TemporalUnit6955] (.truncatedTo this6954 java-time-temporal-TemporalUnit6955)))
(clojure.core/defn range {:arglists (quote (["java.time.OffsetTime" "java.time.temporal.TemporalField"]))} (^java.time.temporal.ValueRange [^java.time.OffsetTime this6956 ^java.time.temporal.TemporalField java-time-temporal-TemporalField6957] (.range this6956 java-time-temporal-TemporalField6957)))
(clojure.core/defn get-hour {:arglists (quote (["java.time.OffsetTime"]))} (^java.lang.Integer [^java.time.OffsetTime this6958] (.getHour this6958)))
(clojure.core/defn minus-hours {:arglists (quote (["java.time.OffsetTime" "long"]))} (^java.time.OffsetTime [^java.time.OffsetTime this6959 ^long long6960] (.minusHours this6959 long6960)))
(clojure.core/defn of {:arglists (quote (["java.time.LocalTime" "java.time.ZoneOffset"] ["int" "int" "int" "int" "java.time.ZoneOffset"]))} (^java.time.OffsetTime [^java.time.LocalTime java-time-LocalTime6961 ^java.time.ZoneOffset java-time-ZoneOffset6962] (java.time.OffsetTime/of java-time-LocalTime6961 java-time-ZoneOffset6962)) (^java.time.OffsetTime [^java.lang.Integer int6963 ^java.lang.Integer int6964 ^java.lang.Integer int6965 ^java.lang.Integer int6966 ^java.time.ZoneOffset java-time-ZoneOffset6967] (java.time.OffsetTime/of int6963 int6964 int6965 int6966 java-time-ZoneOffset6967)))
(clojure.core/defn is-equal {:arglists (quote (["java.time.OffsetTime" "java.time.OffsetTime"]))} (^java.lang.Boolean [^java.time.OffsetTime this6968 ^java.time.OffsetTime java-time-OffsetTime6969] (.isEqual this6968 java-time-OffsetTime6969)))
(clojure.core/defn get-nano {:arglists (quote (["java.time.OffsetTime"]))} (^java.lang.Integer [^java.time.OffsetTime this6970] (.getNano this6970)))
(clojure.core/defn minus-seconds {:arglists (quote (["java.time.OffsetTime" "long"]))} (^java.time.OffsetTime [^java.time.OffsetTime this6971 ^long long6972] (.minusSeconds this6971 long6972)))
(clojure.core/defn get-second {:arglists (quote (["java.time.OffsetTime"]))} (^java.lang.Integer [^java.time.OffsetTime this6973] (.getSecond this6973)))
(clojure.core/defn plus-nanos {:arglists (quote (["java.time.OffsetTime" "long"]))} (^java.time.OffsetTime [^java.time.OffsetTime this6974 ^long long6975] (.plusNanos this6974 long6975)))
(clojure.core/defn plus {:arglists (quote (["java.time.OffsetTime" "java.time.temporal.TemporalAmount"] ["java.time.OffsetTime" "long" "java.time.temporal.TemporalUnit"] ["java.time.OffsetTime" "java.time.temporal.TemporalAmount"] ["java.time.OffsetTime" "long" "java.time.temporal.TemporalUnit"]))} (^java.lang.Object [this6976 G__6977] (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalAmount") G__6977)) (clojure.core/let [G__6977 ^"java.time.temporal.TemporalAmount" G__6977] (.plus ^java.time.OffsetTime this6976 G__6977)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalAmount") G__6977)) (clojure.core/let [G__6977 ^"java.time.temporal.TemporalAmount" G__6977] (.plus ^java.time.OffsetTime this6976 G__6977)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args")))) (^java.lang.Object [this6978 G__6979 G__6980] (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.lang.Long") G__6979) (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalUnit") G__6980)) (clojure.core/let [G__6979 (clojure.core/long G__6979) G__6980 ^"java.time.temporal.TemporalUnit" G__6980] (.plus ^java.time.OffsetTime this6978 G__6979 G__6980)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.lang.Long") G__6979) (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalUnit") G__6980)) (clojure.core/let [G__6979 (clojure.core/long G__6979) G__6980 ^"java.time.temporal.TemporalUnit" G__6980] (.plus ^java.time.OffsetTime this6978 G__6979 G__6980)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args")))))
(clojure.core/defn with-hour {:arglists (quote (["java.time.OffsetTime" "int"]))} (^java.time.OffsetTime [^java.time.OffsetTime this6981 ^java.lang.Integer int6982] (.withHour this6981 int6982)))
(clojure.core/defn with-minute {:arglists (quote (["java.time.OffsetTime" "int"]))} (^java.time.OffsetTime [^java.time.OffsetTime this6983 ^java.lang.Integer int6984] (.withMinute this6983 int6984)))
(clojure.core/defn plus-minutes {:arglists (quote (["java.time.OffsetTime" "long"]))} (^java.time.OffsetTime [^java.time.OffsetTime this6985 ^long long6986] (.plusMinutes this6985 long6986)))
(clojure.core/defn query {:arglists (quote (["java.time.OffsetTime" "java.time.temporal.TemporalQuery"]))} (^java.lang.Object [^java.time.OffsetTime this6987 ^java.time.temporal.TemporalQuery java-time-temporal-TemporalQuery6988] (.query this6987 java-time-temporal-TemporalQuery6988)))
(clojure.core/defn at-date {:arglists (quote (["java.time.OffsetTime" "java.time.LocalDate"]))} (^java.time.OffsetDateTime [^java.time.OffsetTime this6989 ^java.time.LocalDate java-time-LocalDate6990] (.atDate this6989 java-time-LocalDate6990)))
(clojure.core/defn with-offset-same-instant {:arglists (quote (["java.time.OffsetTime" "java.time.ZoneOffset"]))} (^java.time.OffsetTime [^java.time.OffsetTime this6991 ^java.time.ZoneOffset java-time-ZoneOffset6992] (.withOffsetSameInstant this6991 java-time-ZoneOffset6992)))
(clojure.core/defn to-string {:arglists (quote (["java.time.OffsetTime"]))} (^java.lang.String [^java.time.OffsetTime this6993] (.toString this6993)))
(clojure.core/defn is-before {:arglists (quote (["java.time.OffsetTime" "java.time.OffsetTime"]))} (^java.lang.Boolean [^java.time.OffsetTime this6994 ^java.time.OffsetTime java-time-OffsetTime6995] (.isBefore this6994 java-time-OffsetTime6995)))
(clojure.core/defn minus {:arglists (quote (["java.time.OffsetTime" "java.time.temporal.TemporalAmount"] ["java.time.OffsetTime" "long" "java.time.temporal.TemporalUnit"] ["java.time.OffsetTime" "java.time.temporal.TemporalAmount"] ["java.time.OffsetTime" "long" "java.time.temporal.TemporalUnit"]))} (^java.lang.Object [this6996 G__6997] (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalAmount") G__6997)) (clojure.core/let [G__6997 ^"java.time.temporal.TemporalAmount" G__6997] (.minus ^java.time.OffsetTime this6996 G__6997)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalAmount") G__6997)) (clojure.core/let [G__6997 ^"java.time.temporal.TemporalAmount" G__6997] (.minus ^java.time.OffsetTime this6996 G__6997)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args")))) (^java.lang.Object [this6998 G__6999 G__7000] (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.lang.Long") G__6999) (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalUnit") G__7000)) (clojure.core/let [G__6999 (clojure.core/long G__6999) G__7000 ^"java.time.temporal.TemporalUnit" G__7000] (.minus ^java.time.OffsetTime this6998 G__6999 G__7000)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.lang.Long") G__6999) (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalUnit") G__7000)) (clojure.core/let [G__6999 (clojure.core/long G__6999) G__7000 ^"java.time.temporal.TemporalUnit" G__7000] (.minus ^java.time.OffsetTime this6998 G__6999 G__7000)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args")))))
(clojure.core/defn plus-hours {:arglists (quote (["java.time.OffsetTime" "long"]))} (^java.time.OffsetTime [^java.time.OffsetTime this7001 ^long long7002] (.plusHours this7001 long7002)))
(clojure.core/defn to-local-time {:arglists (quote (["java.time.OffsetTime"]))} (^java.time.LocalTime [^java.time.OffsetTime this7003] (.toLocalTime this7003)))
(clojure.core/defn get-long {:arglists (quote (["java.time.OffsetTime" "java.time.temporal.TemporalField"]))} (^long [^java.time.OffsetTime this7004 ^java.time.temporal.TemporalField java-time-temporal-TemporalField7005] (.getLong this7004 java-time-temporal-TemporalField7005)))
(clojure.core/defn get-offset {:arglists (quote (["java.time.OffsetTime"]))} (^java.time.ZoneOffset [^java.time.OffsetTime this7006] (.getOffset this7006)))
(clojure.core/defn with-nano {:arglists (quote (["java.time.OffsetTime" "int"]))} (^java.time.OffsetTime [^java.time.OffsetTime this7007 ^java.lang.Integer int7008] (.withNano this7007 int7008)))
(clojure.core/defn until {:arglists (quote (["java.time.OffsetTime" "java.time.temporal.Temporal" "java.time.temporal.TemporalUnit"]))} (^long [^java.time.OffsetTime this7009 ^java.time.temporal.Temporal java-time-temporal-Temporal7010 ^java.time.temporal.TemporalUnit java-time-temporal-TemporalUnit7011] (.until this7009 java-time-temporal-Temporal7010 java-time-temporal-TemporalUnit7011)))
(clojure.core/defn with-offset-same-local {:arglists (quote (["java.time.OffsetTime" "java.time.ZoneOffset"]))} (^java.time.OffsetTime [^java.time.OffsetTime this7012 ^java.time.ZoneOffset java-time-ZoneOffset7013] (.withOffsetSameLocal this7012 java-time-ZoneOffset7013)))
(clojure.core/defn from {:arglists (quote (["java.time.temporal.TemporalAccessor"]))} (^java.time.OffsetTime [^java.time.temporal.TemporalAccessor java-time-temporal-TemporalAccessor7014] (java.time.OffsetTime/from java-time-temporal-TemporalAccessor7014)))
(clojure.core/defn is-after {:arglists (quote (["java.time.OffsetTime" "java.time.OffsetTime"]))} (^java.lang.Boolean [^java.time.OffsetTime this7015 ^java.time.OffsetTime java-time-OffsetTime7016] (.isAfter this7015 java-time-OffsetTime7016)))
(clojure.core/defn minus-nanos {:arglists (quote (["java.time.OffsetTime" "long"]))} (^java.time.OffsetTime [^java.time.OffsetTime this7017 ^long long7018] (.minusNanos this7017 long7018)))
(clojure.core/defn is-supported {:arglists (quote (["java.time.OffsetTime" "java.time.temporal.TemporalField"] ["java.time.OffsetTime" "java.time.temporal.TemporalUnit"]))} (^java.lang.Boolean [this7019 G__7020] (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalField") G__7020)) (clojure.core/let [G__7020 ^"java.time.temporal.TemporalField" G__7020] (.isSupported ^java.time.OffsetTime this7019 G__7020)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalUnit") G__7020)) (clojure.core/let [G__7020 ^"java.time.temporal.TemporalUnit" G__7020] (.isSupported ^java.time.OffsetTime this7019 G__7020)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args")))))
(clojure.core/defn parse {:arglists (quote (["java.lang.CharSequence" "java.time.format.DateTimeFormatter"] ["java.lang.CharSequence"]))} (^java.time.OffsetTime [^java.lang.CharSequence java-lang-CharSequence7021 ^java.time.format.DateTimeFormatter java-time-format-DateTimeFormatter7022] (java.time.OffsetTime/parse java-lang-CharSequence7021 java-time-format-DateTimeFormatter7022)) (^java.time.OffsetTime [^java.lang.CharSequence java-lang-CharSequence7023] (java.time.OffsetTime/parse java-lang-CharSequence7023)))
(clojure.core/defn with-second {:arglists (quote (["java.time.OffsetTime" "int"]))} (^java.time.OffsetTime [^java.time.OffsetTime this7024 ^java.lang.Integer int7025] (.withSecond this7024 int7025)))
(clojure.core/defn get-minute {:arglists (quote (["java.time.OffsetTime"]))} (^java.lang.Integer [^java.time.OffsetTime this7026] (.getMinute this7026)))
(clojure.core/defn hash-code {:arglists (quote (["java.time.OffsetTime"]))} (^java.lang.Integer [^java.time.OffsetTime this7027] (.hashCode this7027)))
(clojure.core/defn adjust-into {:arglists (quote (["java.time.OffsetTime" "java.time.temporal.Temporal"]))} (^java.time.temporal.Temporal [^java.time.OffsetTime this7028 ^java.time.temporal.Temporal java-time-temporal-Temporal7029] (.adjustInto this7028 java-time-temporal-Temporal7029)))
(clojure.core/defn with {:arglists (quote (["java.time.OffsetTime" "java.time.temporal.TemporalField" "long"] ["java.time.OffsetTime" "java.time.temporal.TemporalField" "long"] ["java.time.OffsetTime" "java.time.temporal.TemporalAdjuster"] ["java.time.OffsetTime" "java.time.temporal.TemporalAdjuster"]))} (^java.lang.Object [this7030 G__7031 G__7032] (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalField") G__7031) (clojure.core/instance? (java.lang.Class/forName "java.lang.Long") G__7032)) (clojure.core/let [G__7031 ^"java.time.temporal.TemporalField" G__7031 G__7032 (clojure.core/long G__7032)] (.with ^java.time.OffsetTime this7030 G__7031 G__7032)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalField") G__7031) (clojure.core/instance? (java.lang.Class/forName "java.lang.Long") G__7032)) (clojure.core/let [G__7031 ^"java.time.temporal.TemporalField" G__7031 G__7032 (clojure.core/long G__7032)] (.with ^java.time.OffsetTime this7030 G__7031 G__7032)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args")))) (^java.lang.Object [this7033 G__7034] (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalAdjuster") G__7034)) (clojure.core/let [G__7034 ^"java.time.temporal.TemporalAdjuster" G__7034] (.with ^java.time.OffsetTime this7033 G__7034)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalAdjuster") G__7034)) (clojure.core/let [G__7034 ^"java.time.temporal.TemporalAdjuster" G__7034] (.with ^java.time.OffsetTime this7033 G__7034)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args")))))
(clojure.core/defn now {:arglists (quote (["java.time.ZoneId"] [] ["java.time.Clock"]))} (^java.time.OffsetTime [G__7036] (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.ZoneId") G__7036)) (clojure.core/let [G__7036 ^"java.time.ZoneId" G__7036] (java.time.OffsetTime/now G__7036)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.Clock") G__7036)) (clojure.core/let [G__7036 ^"java.time.Clock" G__7036] (java.time.OffsetTime/now G__7036)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args")))) (^java.time.OffsetTime [] (java.time.OffsetTime/now)))
(clojure.core/defn compare-to {:arglists (quote (["java.time.OffsetTime" "java.time.OffsetTime"] ["java.time.OffsetTime" "java.lang.Object"]))} (^java.lang.Integer [this7037 G__7038] (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.OffsetTime") G__7038)) (clojure.core/let [G__7038 ^"java.time.OffsetTime" G__7038] (.compareTo ^java.time.OffsetTime this7037 G__7038)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.lang.Object") G__7038)) (clojure.core/let [G__7038 ^"java.lang.Object" G__7038] (.compareTo ^java.time.OffsetTime this7037 G__7038)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args")))))
(clojure.core/defn of-instant {:arglists (quote (["java.time.Instant" "java.time.ZoneId"]))} (^java.time.OffsetTime [^java.time.Instant java-time-Instant7039 ^java.time.ZoneId java-time-ZoneId7040] (java.time.OffsetTime/ofInstant java-time-Instant7039 java-time-ZoneId7040)))
(clojure.core/defn plus-seconds {:arglists (quote (["java.time.OffsetTime" "long"]))} (^java.time.OffsetTime [^java.time.OffsetTime this7041 ^long long7042] (.plusSeconds this7041 long7042)))
(clojure.core/defn get {:arglists (quote (["java.time.OffsetTime" "java.time.temporal.TemporalField"]))} (^java.lang.Integer [^java.time.OffsetTime this7043 ^java.time.temporal.TemporalField java-time-temporal-TemporalField7044] (.get this7043 java-time-temporal-TemporalField7044)))
(clojure.core/defn equals {:arglists (quote (["java.time.OffsetTime" "java.lang.Object"]))} (^java.lang.Boolean [^java.time.OffsetTime this7045 ^java.lang.Object java-lang-Object7046] (.equals this7045 java-lang-Object7046)))
(clojure.core/defn format {:arglists (quote (["java.time.OffsetTime" "java.time.format.DateTimeFormatter"]))} (^java.lang.String [^java.time.OffsetTime this7047 ^java.time.format.DateTimeFormatter java-time-format-DateTimeFormatter7048] (.format this7047 java-time-format-DateTimeFormatter7048)))
