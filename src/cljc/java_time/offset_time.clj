(ns cljc.java-time.offset-time (:refer-clojure :exclude [get range format min max next name resolve]) (:import [java.time OffsetTime]))
(def min (. java.time.OffsetTime -MIN))
(def max (. java.time.OffsetTime -MAX))
(clojure.core/defn minus-minutes {:arglists (quote (["java.time.OffsetTime" "long"]))} (^java.time.OffsetTime [^java.time.OffsetTime this6581 ^long long6582] (.minusMinutes this6581 long6582)))
(clojure.core/defn truncated-to {:arglists (quote (["java.time.OffsetTime" "java.time.temporal.TemporalUnit"]))} (^java.time.OffsetTime [^java.time.OffsetTime this6583 ^java.time.temporal.TemporalUnit java-time-temporal-TemporalUnit6584] (.truncatedTo this6583 java-time-temporal-TemporalUnit6584)))
(clojure.core/defn range {:arglists (quote (["java.time.OffsetTime" "java.time.temporal.TemporalField"]))} (^java.time.temporal.ValueRange [^java.time.OffsetTime this6585 ^java.time.temporal.TemporalField java-time-temporal-TemporalField6586] (.range this6585 java-time-temporal-TemporalField6586)))
(clojure.core/defn get-hour {:arglists (quote (["java.time.OffsetTime"]))} (^java.lang.Integer [^java.time.OffsetTime this6587] (.getHour this6587)))
(clojure.core/defn minus-hours {:arglists (quote (["java.time.OffsetTime" "long"]))} (^java.time.OffsetTime [^java.time.OffsetTime this6588 ^long long6589] (.minusHours this6588 long6589)))
(clojure.core/defn of {:arglists (quote (["java.time.LocalTime" "java.time.ZoneOffset"] ["int" "int" "int" "int" "java.time.ZoneOffset"]))} (^java.time.OffsetTime [^java.time.LocalTime java-time-LocalTime6590 ^java.time.ZoneOffset java-time-ZoneOffset6591] (. java.time.OffsetTime of java-time-LocalTime6590 java-time-ZoneOffset6591)) (^java.time.OffsetTime [^java.lang.Integer int6592 ^java.lang.Integer int6593 ^java.lang.Integer int6594 ^java.lang.Integer int6595 ^java.time.ZoneOffset java-time-ZoneOffset6596] (. java.time.OffsetTime of int6592 int6593 int6594 int6595 java-time-ZoneOffset6596)))
(clojure.core/defn is-equal {:arglists (quote (["java.time.OffsetTime" "java.time.OffsetTime"]))} (^java.lang.Boolean [^java.time.OffsetTime this6597 ^java.time.OffsetTime java-time-OffsetTime6598] (.isEqual this6597 java-time-OffsetTime6598)))
(clojure.core/defn get-nano {:arglists (quote (["java.time.OffsetTime"]))} (^java.lang.Integer [^java.time.OffsetTime this6599] (.getNano this6599)))
(clojure.core/defn minus-seconds {:arglists (quote (["java.time.OffsetTime" "long"]))} (^java.time.OffsetTime [^java.time.OffsetTime this6600 ^long long6601] (.minusSeconds this6600 long6601)))
(clojure.core/defn get-second {:arglists (quote (["java.time.OffsetTime"]))} (^java.lang.Integer [^java.time.OffsetTime this6602] (.getSecond this6602)))
(clojure.core/defn plus-nanos {:arglists (quote (["java.time.OffsetTime" "long"]))} (^java.time.OffsetTime [^java.time.OffsetTime this6603 ^long long6604] (.plusNanos this6603 long6604)))
(clojure.core/defn plus {:arglists (quote (["java.time.OffsetTime" "long" "java.time.temporal.TemporalUnit"] ["java.time.OffsetTime" "java.time.temporal.TemporalAmount"] ["java.time.OffsetTime" "java.time.temporal.TemporalAmount"] ["java.time.OffsetTime" "long" "java.time.temporal.TemporalUnit"]))} (^java.lang.Object [this6605 G__6606 G__6607] (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.lang.Long") G__6606) (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalUnit") G__6607)) (clojure.core/let [G__6606 (clojure.core/long G__6606) G__6607 ^"java.time.temporal.TemporalUnit" G__6607] (.plus ^java.time.OffsetTime this6605 G__6606 G__6607)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.lang.Long") G__6606) (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalUnit") G__6607)) (clojure.core/let [G__6606 (clojure.core/long G__6606) G__6607 ^"java.time.temporal.TemporalUnit" G__6607] (.plus ^java.time.OffsetTime this6605 G__6606 G__6607)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args")))) (^java.lang.Object [this6608 G__6609] (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalAmount") G__6609)) (clojure.core/let [G__6609 ^"java.time.temporal.TemporalAmount" G__6609] (.plus ^java.time.OffsetTime this6608 G__6609)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalAmount") G__6609)) (clojure.core/let [G__6609 ^"java.time.temporal.TemporalAmount" G__6609] (.plus ^java.time.OffsetTime this6608 G__6609)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args")))))
(clojure.core/defn with-hour {:arglists (quote (["java.time.OffsetTime" "int"]))} (^java.time.OffsetTime [^java.time.OffsetTime this6610 ^java.lang.Integer int6611] (.withHour this6610 int6611)))
(clojure.core/defn with-minute {:arglists (quote (["java.time.OffsetTime" "int"]))} (^java.time.OffsetTime [^java.time.OffsetTime this6612 ^java.lang.Integer int6613] (.withMinute this6612 int6613)))
(clojure.core/defn plus-minutes {:arglists (quote (["java.time.OffsetTime" "long"]))} (^java.time.OffsetTime [^java.time.OffsetTime this6614 ^long long6615] (.plusMinutes this6614 long6615)))
(clojure.core/defn query {:arglists (quote (["java.time.OffsetTime" "java.time.temporal.TemporalQuery"]))} (^java.lang.Object [^java.time.OffsetTime this6616 ^java.time.temporal.TemporalQuery java-time-temporal-TemporalQuery6617] (.query this6616 java-time-temporal-TemporalQuery6617)))
(clojure.core/defn at-date {:arglists (quote (["java.time.OffsetTime" "java.time.LocalDate"]))} (^java.time.OffsetDateTime [^java.time.OffsetTime this6618 ^java.time.LocalDate java-time-LocalDate6619] (.atDate this6618 java-time-LocalDate6619)))
(clojure.core/defn with-offset-same-instant {:arglists (quote (["java.time.OffsetTime" "java.time.ZoneOffset"]))} (^java.time.OffsetTime [^java.time.OffsetTime this6620 ^java.time.ZoneOffset java-time-ZoneOffset6621] (.withOffsetSameInstant this6620 java-time-ZoneOffset6621)))
(clojure.core/defn to-string {:arglists (quote (["java.time.OffsetTime"]))} (^java.lang.String [^java.time.OffsetTime this6622] (.toString this6622)))
(clojure.core/defn is-before {:arglists (quote (["java.time.OffsetTime" "java.time.OffsetTime"]))} (^java.lang.Boolean [^java.time.OffsetTime this6623 ^java.time.OffsetTime java-time-OffsetTime6624] (.isBefore this6623 java-time-OffsetTime6624)))
(clojure.core/defn minus {:arglists (quote (["java.time.OffsetTime" "java.time.temporal.TemporalAmount"] ["java.time.OffsetTime" "long" "java.time.temporal.TemporalUnit"] ["java.time.OffsetTime" "long" "java.time.temporal.TemporalUnit"] ["java.time.OffsetTime" "java.time.temporal.TemporalAmount"]))} (^java.lang.Object [this6625 G__6626] (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalAmount") G__6626)) (clojure.core/let [G__6626 ^"java.time.temporal.TemporalAmount" G__6626] (.minus ^java.time.OffsetTime this6625 G__6626)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalAmount") G__6626)) (clojure.core/let [G__6626 ^"java.time.temporal.TemporalAmount" G__6626] (.minus ^java.time.OffsetTime this6625 G__6626)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args")))) (^java.lang.Object [this6627 G__6628 G__6629] (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.lang.Long") G__6628) (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalUnit") G__6629)) (clojure.core/let [G__6628 (clojure.core/long G__6628) G__6629 ^"java.time.temporal.TemporalUnit" G__6629] (.minus ^java.time.OffsetTime this6627 G__6628 G__6629)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.lang.Long") G__6628) (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalUnit") G__6629)) (clojure.core/let [G__6628 (clojure.core/long G__6628) G__6629 ^"java.time.temporal.TemporalUnit" G__6629] (.minus ^java.time.OffsetTime this6627 G__6628 G__6629)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args")))))
(clojure.core/defn plus-hours {:arglists (quote (["java.time.OffsetTime" "long"]))} (^java.time.OffsetTime [^java.time.OffsetTime this6630 ^long long6631] (.plusHours this6630 long6631)))
(clojure.core/defn to-local-time {:arglists (quote (["java.time.OffsetTime"]))} (^java.time.LocalTime [^java.time.OffsetTime this6632] (.toLocalTime this6632)))
(clojure.core/defn get-long {:arglists (quote (["java.time.OffsetTime" "java.time.temporal.TemporalField"]))} (^long [^java.time.OffsetTime this6633 ^java.time.temporal.TemporalField java-time-temporal-TemporalField6634] (.getLong this6633 java-time-temporal-TemporalField6634)))
(clojure.core/defn get-offset {:arglists (quote (["java.time.OffsetTime"]))} (^java.time.ZoneOffset [^java.time.OffsetTime this6635] (.getOffset this6635)))
(clojure.core/defn with-nano {:arglists (quote (["java.time.OffsetTime" "int"]))} (^java.time.OffsetTime [^java.time.OffsetTime this6636 ^java.lang.Integer int6637] (.withNano this6636 int6637)))
(clojure.core/defn until {:arglists (quote (["java.time.OffsetTime" "java.time.temporal.Temporal" "java.time.temporal.TemporalUnit"]))} (^long [^java.time.OffsetTime this6638 ^java.time.temporal.Temporal java-time-temporal-Temporal6639 ^java.time.temporal.TemporalUnit java-time-temporal-TemporalUnit6640] (.until this6638 java-time-temporal-Temporal6639 java-time-temporal-TemporalUnit6640)))
(clojure.core/defn with-offset-same-local {:arglists (quote (["java.time.OffsetTime" "java.time.ZoneOffset"]))} (^java.time.OffsetTime [^java.time.OffsetTime this6641 ^java.time.ZoneOffset java-time-ZoneOffset6642] (.withOffsetSameLocal this6641 java-time-ZoneOffset6642)))
(clojure.core/defn from {:arglists (quote (["java.time.temporal.TemporalAccessor"]))} (^java.time.OffsetTime [^java.time.temporal.TemporalAccessor java-time-temporal-TemporalAccessor6643] (. java.time.OffsetTime from java-time-temporal-TemporalAccessor6643)))
(clojure.core/defn is-after {:arglists (quote (["java.time.OffsetTime" "java.time.OffsetTime"]))} (^java.lang.Boolean [^java.time.OffsetTime this6644 ^java.time.OffsetTime java-time-OffsetTime6645] (.isAfter this6644 java-time-OffsetTime6645)))
(clojure.core/defn minus-nanos {:arglists (quote (["java.time.OffsetTime" "long"]))} (^java.time.OffsetTime [^java.time.OffsetTime this6646 ^long long6647] (.minusNanos this6646 long6647)))
(clojure.core/defn is-supported {:arglists (quote (["java.time.OffsetTime" "java.time.temporal.TemporalField"] ["java.time.OffsetTime" "java.time.temporal.TemporalUnit"]))} (^java.lang.Boolean [this6648 G__6649] (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalField") G__6649)) (clojure.core/let [G__6649 ^"java.time.temporal.TemporalField" G__6649] (.isSupported ^java.time.OffsetTime this6648 G__6649)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalUnit") G__6649)) (clojure.core/let [G__6649 ^"java.time.temporal.TemporalUnit" G__6649] (.isSupported ^java.time.OffsetTime this6648 G__6649)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args")))))
(clojure.core/defn parse {:arglists (quote (["java.lang.CharSequence"] ["java.lang.CharSequence" "java.time.format.DateTimeFormatter"]))} (^java.time.OffsetTime [^java.lang.CharSequence java-lang-CharSequence6650] (. java.time.OffsetTime parse java-lang-CharSequence6650)) (^java.time.OffsetTime [^java.lang.CharSequence java-lang-CharSequence6651 ^java.time.format.DateTimeFormatter java-time-format-DateTimeFormatter6652] (. java.time.OffsetTime parse java-lang-CharSequence6651 java-time-format-DateTimeFormatter6652)))
(clojure.core/defn with-second {:arglists (quote (["java.time.OffsetTime" "int"]))} (^java.time.OffsetTime [^java.time.OffsetTime this6653 ^java.lang.Integer int6654] (.withSecond this6653 int6654)))
(clojure.core/defn get-minute {:arglists (quote (["java.time.OffsetTime"]))} (^java.lang.Integer [^java.time.OffsetTime this6655] (.getMinute this6655)))
(clojure.core/defn hash-code {:arglists (quote (["java.time.OffsetTime"]))} (^java.lang.Integer [^java.time.OffsetTime this6656] (.hashCode this6656)))
(clojure.core/defn adjust-into {:arglists (quote (["java.time.OffsetTime" "java.time.temporal.Temporal"]))} (^java.time.temporal.Temporal [^java.time.OffsetTime this6657 ^java.time.temporal.Temporal java-time-temporal-Temporal6658] (.adjustInto this6657 java-time-temporal-Temporal6658)))
(clojure.core/defn with {:arglists (quote (["java.time.OffsetTime" "java.time.temporal.TemporalAdjuster"] ["java.time.OffsetTime" "java.time.temporal.TemporalAdjuster"] ["java.time.OffsetTime" "java.time.temporal.TemporalField" "long"] ["java.time.OffsetTime" "java.time.temporal.TemporalField" "long"]))} (^java.lang.Object [this6659 G__6660] (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalAdjuster") G__6660)) (clojure.core/let [G__6660 ^"java.time.temporal.TemporalAdjuster" G__6660] (.with ^java.time.OffsetTime this6659 G__6660)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalAdjuster") G__6660)) (clojure.core/let [G__6660 ^"java.time.temporal.TemporalAdjuster" G__6660] (.with ^java.time.OffsetTime this6659 G__6660)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args")))) (^java.lang.Object [this6661 G__6662 G__6663] (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalField") G__6662) (clojure.core/instance? (java.lang.Class/forName "java.lang.Long") G__6663)) (clojure.core/let [G__6662 ^"java.time.temporal.TemporalField" G__6662 G__6663 (clojure.core/long G__6663)] (.with ^java.time.OffsetTime this6661 G__6662 G__6663)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalField") G__6662) (clojure.core/instance? (java.lang.Class/forName "java.lang.Long") G__6663)) (clojure.core/let [G__6662 ^"java.time.temporal.TemporalField" G__6662 G__6663 (clojure.core/long G__6663)] (.with ^java.time.OffsetTime this6661 G__6662 G__6663)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args")))))
(clojure.core/defn now {:arglists (quote (["java.time.ZoneId"] ["java.time.Clock"] []))} (^java.time.OffsetTime [G__6665] (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.ZoneId") G__6665)) (clojure.core/let [G__6665 ^"java.time.ZoneId" G__6665] (. java.time.OffsetTime now G__6665)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.Clock") G__6665)) (clojure.core/let [G__6665 ^"java.time.Clock" G__6665] (. java.time.OffsetTime now G__6665)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args")))) (^java.time.OffsetTime [] (. java.time.OffsetTime now)))
(clojure.core/defn compare-to {:arglists (quote (["java.time.OffsetTime" "java.time.OffsetTime"] ["java.time.OffsetTime" "java.lang.Object"]))} (^java.lang.Integer [this6666 G__6667] (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.OffsetTime") G__6667)) (clojure.core/let [G__6667 ^"java.time.OffsetTime" G__6667] (.compareTo ^java.time.OffsetTime this6666 G__6667)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.lang.Object") G__6667)) (clojure.core/let [G__6667 ^"java.lang.Object" G__6667] (.compareTo ^java.time.OffsetTime this6666 G__6667)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args")))))
(clojure.core/defn of-instant {:arglists (quote (["java.time.Instant" "java.time.ZoneId"]))} (^java.time.OffsetTime [^java.time.Instant java-time-Instant6668 ^java.time.ZoneId java-time-ZoneId6669] (. java.time.OffsetTime ofInstant java-time-Instant6668 java-time-ZoneId6669)))
(clojure.core/defn plus-seconds {:arglists (quote (["java.time.OffsetTime" "long"]))} (^java.time.OffsetTime [^java.time.OffsetTime this6670 ^long long6671] (.plusSeconds this6670 long6671)))
(clojure.core/defn get {:arglists (quote (["java.time.OffsetTime" "java.time.temporal.TemporalField"]))} (^java.lang.Integer [^java.time.OffsetTime this6672 ^java.time.temporal.TemporalField java-time-temporal-TemporalField6673] (.get this6672 java-time-temporal-TemporalField6673)))
(clojure.core/defn equals {:arglists (quote (["java.time.OffsetTime" "java.lang.Object"]))} (^java.lang.Boolean [^java.time.OffsetTime this6674 ^java.lang.Object java-lang-Object6675] (.equals this6674 java-lang-Object6675)))
(clojure.core/defn format {:arglists (quote (["java.time.OffsetTime" "java.time.format.DateTimeFormatter"]))} (^java.lang.String [^java.time.OffsetTime this6676 ^java.time.format.DateTimeFormatter java-time-format-DateTimeFormatter6677] (.format this6676 java-time-format-DateTimeFormatter6677)))
