(ns cljc.java-time.month-day (:refer-clojure :exclude [get range format min max next name resolve short]) (:require [cljc.java-time.extn.calendar-awareness]) (:import [java.time MonthDay]))
(clojure.core/defn at-year {:arglists (quote (["java.time.MonthDay" "int"]))} (^java.time.LocalDate [^java.time.MonthDay this60652 ^java.lang.Integer int60653] (.atYear this60652 int60653)))
(clojure.core/defn range {:arglists (quote (["java.time.MonthDay" "java.time.temporal.TemporalField"]))} (^java.time.temporal.ValueRange [^java.time.MonthDay this60654 ^java.time.temporal.TemporalField java-time-temporal-TemporalField60655] (.range this60654 java-time-temporal-TemporalField60655)))
(clojure.core/defn of {:arglists (quote (["java.time.Month" "int"] ["int" "int"]))} (^java.time.MonthDay [G__60657 G__60658] (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.Month") G__60657) (clojure.core/instance? (java.lang.Class/forName "java.lang.Number") G__60658)) (clojure.core/let [G__60657 ^"java.time.Month" G__60657 G__60658 (clojure.core/int G__60658)] (java.time.MonthDay/of G__60657 G__60658)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.lang.Number") G__60657) (clojure.core/instance? (java.lang.Class/forName "java.lang.Number") G__60658)) (clojure.core/let [G__60657 (clojure.core/int G__60657) G__60658 (clojure.core/int G__60658)] (java.time.MonthDay/of G__60657 G__60658)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args")))))
(clojure.core/defn with-month {:arglists (quote (["java.time.MonthDay" "int"]))} (^java.time.MonthDay [^java.time.MonthDay this60659 ^java.lang.Integer int60660] (.withMonth this60659 int60660)))
(clojure.core/defn query {:arglists (quote (["java.time.MonthDay" "java.time.temporal.TemporalQuery"]))} (^java.lang.Object [^java.time.MonthDay this60661 ^java.time.temporal.TemporalQuery java-time-temporal-TemporalQuery60662] (.query this60661 java-time-temporal-TemporalQuery60662)))
(clojure.core/defn to-string {:arglists (quote (["java.time.MonthDay"]))} (^java.lang.String [^java.time.MonthDay this60663] (.toString this60663)))
(clojure.core/defn is-before {:arglists (quote (["java.time.MonthDay" "java.time.MonthDay"]))} (^java.lang.Boolean [^java.time.MonthDay this60664 ^java.time.MonthDay java-time-MonthDay60665] (.isBefore this60664 java-time-MonthDay60665)))
(clojure.core/defn get-long {:arglists (quote (["java.time.MonthDay" "java.time.temporal.TemporalField"]))} (^long [^java.time.MonthDay this60666 ^java.time.temporal.TemporalField java-time-temporal-TemporalField60667] (.getLong this60666 java-time-temporal-TemporalField60667)))
(clojure.core/defn with-day-of-month {:arglists (quote (["java.time.MonthDay" "int"]))} (^java.time.MonthDay [^java.time.MonthDay this60668 ^java.lang.Integer int60669] (.withDayOfMonth this60668 int60669)))
(clojure.core/defn get-day-of-month {:arglists (quote (["java.time.MonthDay"]))} (^java.lang.Integer [^java.time.MonthDay this60670] (.getDayOfMonth this60670)))
(clojure.core/defn from {:arglists (quote (["java.time.temporal.TemporalAccessor"]))} (^java.time.MonthDay [^java.time.temporal.TemporalAccessor java-time-temporal-TemporalAccessor60671] (java.time.MonthDay/from java-time-temporal-TemporalAccessor60671)))
(clojure.core/defn is-after {:arglists (quote (["java.time.MonthDay" "java.time.MonthDay"]))} (^java.lang.Boolean [^java.time.MonthDay this60672 ^java.time.MonthDay java-time-MonthDay60673] (.isAfter this60672 java-time-MonthDay60673)))
(clojure.core/defn is-supported {:arglists (quote (["java.time.MonthDay" "java.time.temporal.TemporalField"]))} (^java.lang.Boolean [^java.time.MonthDay this60674 ^java.time.temporal.TemporalField java-time-temporal-TemporalField60675] (.isSupported this60674 java-time-temporal-TemporalField60675)))
(clojure.core/defn parse {:arglists (quote (["java.lang.CharSequence" "java.time.format.DateTimeFormatter"] ["java.lang.CharSequence"]))} (^java.time.MonthDay [^java.lang.CharSequence java-lang-CharSequence60676 ^java.time.format.DateTimeFormatter java-time-format-DateTimeFormatter60677] (java.time.MonthDay/parse java-lang-CharSequence60676 java-time-format-DateTimeFormatter60677)) (^java.time.MonthDay [^java.lang.CharSequence java-lang-CharSequence60678] (java.time.MonthDay/parse java-lang-CharSequence60678)))
(clojure.core/defn is-valid-year {:arglists (quote (["java.time.MonthDay" "int"]))} (^java.lang.Boolean [^java.time.MonthDay this60679 ^java.lang.Integer int60680] (.isValidYear this60679 int60680)))
(clojure.core/defn hash-code {:arglists (quote (["java.time.MonthDay"]))} (^java.lang.Integer [^java.time.MonthDay this60681] (.hashCode this60681)))
(clojure.core/defn adjust-into {:arglists (quote (["java.time.MonthDay" "java.time.temporal.Temporal"]))} (^java.time.temporal.Temporal [^java.time.MonthDay this60682 ^java.time.temporal.Temporal java-time-temporal-Temporal60683] (.adjustInto this60682 java-time-temporal-Temporal60683)))
(clojure.core/defn with {:arglists (quote (["java.time.MonthDay" "java.time.Month"]))} (^java.time.MonthDay [^java.time.MonthDay this60684 ^java.time.Month java-time-Month60685] (.with this60684 java-time-Month60685)))
(clojure.core/defn now {:arglists (quote ([] ["java.time.Clock"] ["java.time.ZoneId"]))} (^java.time.MonthDay [] (java.time.MonthDay/now)) (^java.time.MonthDay [G__60687] (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.Clock") G__60687)) (clojure.core/let [G__60687 ^"java.time.Clock" G__60687] (java.time.MonthDay/now G__60687)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.ZoneId") G__60687)) (clojure.core/let [G__60687 ^"java.time.ZoneId" G__60687] (java.time.MonthDay/now G__60687)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args")))))
(clojure.core/defn get-month-value {:arglists (quote (["java.time.MonthDay"]))} (^java.lang.Integer [^java.time.MonthDay this60688] (.getMonthValue this60688)))
(clojure.core/defn compare-to {:arglists (quote (["java.time.MonthDay" "java.lang.Object"] ["java.time.MonthDay" "java.time.MonthDay"]))} (^java.lang.Integer [this60689 G__60690] (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.lang.Object") G__60690)) (clojure.core/let [G__60690 ^"java.lang.Object" G__60690] (.compareTo ^java.time.MonthDay this60689 G__60690)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.MonthDay") G__60690)) (clojure.core/let [G__60690 ^"java.time.MonthDay" G__60690] (.compareTo ^java.time.MonthDay this60689 G__60690)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args")))))
(clojure.core/defn get-month {:arglists (quote (["java.time.MonthDay"]))} (^java.time.Month [^java.time.MonthDay this60691] (.getMonth this60691)))
(clojure.core/defn get {:arglists (quote (["java.time.MonthDay" "java.time.temporal.TemporalField"]))} (^java.lang.Integer [^java.time.MonthDay this60692 ^java.time.temporal.TemporalField java-time-temporal-TemporalField60693] (.get this60692 java-time-temporal-TemporalField60693)))
(clojure.core/defn equals {:arglists (quote (["java.time.MonthDay" "java.lang.Object"]))} (^java.lang.Boolean [^java.time.MonthDay this60694 ^java.lang.Object java-lang-Object60695] (.equals this60694 java-lang-Object60695)))
(clojure.core/defn format {:arglists (quote (["java.time.MonthDay" "java.time.format.DateTimeFormatter"]))} (^java.lang.String [^java.time.MonthDay this60696 ^java.time.format.DateTimeFormatter java-time-format-DateTimeFormatter60697] (.format this60696 java-time-format-DateTimeFormatter60697)))
