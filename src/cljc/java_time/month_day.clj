(ns cljc.java-time.month-day (:import [java.time MonthDay]) (:refer-clojure :exclude [get range format min max next name resolve short]))
(clojure.core/defn at-year {:arglists (quote (["java.time.MonthDay" "int"]))} (^java.time.LocalDate [^java.time.MonthDay this50161 ^java.lang.Integer int50162] (.atYear this50161 int50162)))
(clojure.core/defn range {:arglists (quote (["java.time.MonthDay" "java.time.temporal.TemporalField"]))} (^java.time.temporal.ValueRange [^java.time.MonthDay this50163 ^java.time.temporal.TemporalField java-time-temporal-TemporalField50164] (.range this50163 java-time-temporal-TemporalField50164)))
(clojure.core/defn of {:arglists (quote (["java.time.Month" "int"] ["int" "int"]))} (^java.time.MonthDay [G__50166 G__50167] (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.Month") G__50166) (clojure.core/instance? (java.lang.Class/forName "java.lang.Number") G__50167)) (clojure.core/let [G__50166 ^"java.time.Month" G__50166 G__50167 (clojure.core/int G__50167)] (. java.time.MonthDay of G__50166 G__50167)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.lang.Number") G__50166) (clojure.core/instance? (java.lang.Class/forName "java.lang.Number") G__50167)) (clojure.core/let [G__50166 (clojure.core/int G__50166) G__50167 (clojure.core/int G__50167)] (. java.time.MonthDay of G__50166 G__50167)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args")))))
(clojure.core/defn with-month {:arglists (quote (["java.time.MonthDay" "int"]))} (^java.time.MonthDay [^java.time.MonthDay this50168 ^java.lang.Integer int50169] (.withMonth this50168 int50169)))
(clojure.core/defn query {:arglists (quote (["java.time.MonthDay" "java.time.temporal.TemporalQuery"]))} (^java.lang.Object [^java.time.MonthDay this50170 ^java.time.temporal.TemporalQuery java-time-temporal-TemporalQuery50171] (.query this50170 java-time-temporal-TemporalQuery50171)))
(clojure.core/defn to-string {:arglists (quote (["java.time.MonthDay"]))} (^java.lang.String [^java.time.MonthDay this50172] (.toString this50172)))
(clojure.core/defn is-before {:arglists (quote (["java.time.MonthDay" "java.time.MonthDay"]))} (^java.lang.Boolean [^java.time.MonthDay this50173 ^java.time.MonthDay java-time-MonthDay50174] (.isBefore this50173 java-time-MonthDay50174)))
(clojure.core/defn get-long {:arglists (quote (["java.time.MonthDay" "java.time.temporal.TemporalField"]))} (^long [^java.time.MonthDay this50175 ^java.time.temporal.TemporalField java-time-temporal-TemporalField50176] (.getLong this50175 java-time-temporal-TemporalField50176)))
(clojure.core/defn with-day-of-month {:arglists (quote (["java.time.MonthDay" "int"]))} (^java.time.MonthDay [^java.time.MonthDay this50177 ^java.lang.Integer int50178] (.withDayOfMonth this50177 int50178)))
(clojure.core/defn get-day-of-month {:arglists (quote (["java.time.MonthDay"]))} (^java.lang.Integer [^java.time.MonthDay this50179] (.getDayOfMonth this50179)))
(clojure.core/defn from {:arglists (quote (["java.time.temporal.TemporalAccessor"]))} (^java.time.MonthDay [^java.time.temporal.TemporalAccessor java-time-temporal-TemporalAccessor50180] (. java.time.MonthDay from java-time-temporal-TemporalAccessor50180)))
(clojure.core/defn is-after {:arglists (quote (["java.time.MonthDay" "java.time.MonthDay"]))} (^java.lang.Boolean [^java.time.MonthDay this50181 ^java.time.MonthDay java-time-MonthDay50182] (.isAfter this50181 java-time-MonthDay50182)))
(clojure.core/defn is-supported {:arglists (quote (["java.time.MonthDay" "java.time.temporal.TemporalField"]))} (^java.lang.Boolean [^java.time.MonthDay this50183 ^java.time.temporal.TemporalField java-time-temporal-TemporalField50184] (.isSupported this50183 java-time-temporal-TemporalField50184)))
(clojure.core/defn parse {:arglists (quote (["java.lang.CharSequence"] ["java.lang.CharSequence" "java.time.format.DateTimeFormatter"]))} (^java.time.MonthDay [^java.lang.CharSequence java-lang-CharSequence50185] (. java.time.MonthDay parse java-lang-CharSequence50185)) (^java.time.MonthDay [^java.lang.CharSequence java-lang-CharSequence50186 ^java.time.format.DateTimeFormatter java-time-format-DateTimeFormatter50187] (. java.time.MonthDay parse java-lang-CharSequence50186 java-time-format-DateTimeFormatter50187)))
(clojure.core/defn is-valid-year {:arglists (quote (["java.time.MonthDay" "int"]))} (^java.lang.Boolean [^java.time.MonthDay this50188 ^java.lang.Integer int50189] (.isValidYear this50188 int50189)))
(clojure.core/defn hash-code {:arglists (quote (["java.time.MonthDay"]))} (^java.lang.Integer [^java.time.MonthDay this50190] (.hashCode this50190)))
(clojure.core/defn adjust-into {:arglists (quote (["java.time.MonthDay" "java.time.temporal.Temporal"]))} (^java.time.temporal.Temporal [^java.time.MonthDay this50191 ^java.time.temporal.Temporal java-time-temporal-Temporal50192] (.adjustInto this50191 java-time-temporal-Temporal50192)))
(clojure.core/defn with {:arglists (quote (["java.time.MonthDay" "java.time.Month"]))} (^java.time.MonthDay [^java.time.MonthDay this50193 ^java.time.Month java-time-Month50194] (.with this50193 java-time-Month50194)))
(clojure.core/defn now {:arglists (quote (["java.time.ZoneId"] [] ["java.time.Clock"]))} (^java.time.MonthDay [G__50196] (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.ZoneId") G__50196)) (clojure.core/let [G__50196 ^"java.time.ZoneId" G__50196] (. java.time.MonthDay now G__50196)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.Clock") G__50196)) (clojure.core/let [G__50196 ^"java.time.Clock" G__50196] (. java.time.MonthDay now G__50196)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args")))) (^java.time.MonthDay [] (. java.time.MonthDay now)))
(clojure.core/defn get-month-value {:arglists (quote (["java.time.MonthDay"]))} (^java.lang.Integer [^java.time.MonthDay this50197] (.getMonthValue this50197)))
(clojure.core/defn compare-to {:arglists (quote (["java.time.MonthDay" "java.lang.Object"] ["java.time.MonthDay" "java.time.MonthDay"]))} (^java.lang.Integer [this50198 G__50199] (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.lang.Object") G__50199)) (clojure.core/let [G__50199 ^"java.lang.Object" G__50199] (.compareTo ^java.time.MonthDay this50198 G__50199)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.MonthDay") G__50199)) (clojure.core/let [G__50199 ^"java.time.MonthDay" G__50199] (.compareTo ^java.time.MonthDay this50198 G__50199)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args")))))
(clojure.core/defn get-month {:arglists (quote (["java.time.MonthDay"]))} (^java.time.Month [^java.time.MonthDay this50200] (.getMonth this50200)))
(clojure.core/defn get {:arglists (quote (["java.time.MonthDay" "java.time.temporal.TemporalField"]))} (^java.lang.Integer [^java.time.MonthDay this50201 ^java.time.temporal.TemporalField java-time-temporal-TemporalField50202] (.get this50201 java-time-temporal-TemporalField50202)))
(clojure.core/defn equals {:arglists (quote (["java.time.MonthDay" "java.lang.Object"]))} (^java.lang.Boolean [^java.time.MonthDay this50203 ^java.lang.Object java-lang-Object50204] (.equals this50203 java-lang-Object50204)))
(clojure.core/defn format {:arglists (quote (["java.time.MonthDay" "java.time.format.DateTimeFormatter"]))} (^java.lang.String [^java.time.MonthDay this50205 ^java.time.format.DateTimeFormatter java-time-format-DateTimeFormatter50206] (.format this50205 java-time-format-DateTimeFormatter50206)))
