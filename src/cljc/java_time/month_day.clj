(ns cljc.java-time.month-day (:refer-clojure :exclude [get range format min max next name resolve short]) (:require [cljc.java-time.extn.calendar-awareness]) (:import [java.time MonthDay]))
(clojure.core/defn at-year {:arglists (quote (["java.time.MonthDay" "int"]))} (^java.time.LocalDate [^java.time.MonthDay this7970 ^java.lang.Integer int7971] (.atYear this7970 int7971)))
(clojure.core/defn range {:arglists (quote (["java.time.MonthDay" "java.time.temporal.TemporalField"]))} (^java.time.temporal.ValueRange [^java.time.MonthDay this7972 ^java.time.temporal.TemporalField java-time-temporal-TemporalField7973] (.range this7972 java-time-temporal-TemporalField7973)))
(clojure.core/defn of {:arglists (quote (["java.time.Month" "int"] ["int" "int"]))} (^java.time.MonthDay [G__7975 G__7976] (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.Month") G__7975) (clojure.core/instance? (java.lang.Class/forName "java.lang.Number") G__7976)) (clojure.core/let [G__7975 ^"java.time.Month" G__7975 G__7976 (clojure.core/int G__7976)] (java.time.MonthDay/of G__7975 G__7976)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.lang.Number") G__7975) (clojure.core/instance? (java.lang.Class/forName "java.lang.Number") G__7976)) (clojure.core/let [G__7975 (clojure.core/int G__7975) G__7976 (clojure.core/int G__7976)] (java.time.MonthDay/of G__7975 G__7976)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args")))))
(clojure.core/defn with-month {:arglists (quote (["java.time.MonthDay" "int"]))} (^java.time.MonthDay [^java.time.MonthDay this7977 ^java.lang.Integer int7978] (.withMonth this7977 int7978)))
(clojure.core/defn query {:arglists (quote (["java.time.MonthDay" "java.time.temporal.TemporalQuery"]))} (^java.lang.Object [^java.time.MonthDay this7979 ^java.time.temporal.TemporalQuery java-time-temporal-TemporalQuery7980] (.query this7979 java-time-temporal-TemporalQuery7980)))
(clojure.core/defn to-string {:arglists (quote (["java.time.MonthDay"]))} (^java.lang.String [^java.time.MonthDay this7981] (.toString this7981)))
(clojure.core/defn is-before {:arglists (quote (["java.time.MonthDay" "java.time.MonthDay"]))} (^java.lang.Boolean [^java.time.MonthDay this7982 ^java.time.MonthDay java-time-MonthDay7983] (.isBefore this7982 java-time-MonthDay7983)))
(clojure.core/defn get-long {:arglists (quote (["java.time.MonthDay" "java.time.temporal.TemporalField"]))} (^long [^java.time.MonthDay this7984 ^java.time.temporal.TemporalField java-time-temporal-TemporalField7985] (.getLong this7984 java-time-temporal-TemporalField7985)))
(clojure.core/defn with-day-of-month {:arglists (quote (["java.time.MonthDay" "int"]))} (^java.time.MonthDay [^java.time.MonthDay this7986 ^java.lang.Integer int7987] (.withDayOfMonth this7986 int7987)))
(clojure.core/defn get-day-of-month {:arglists (quote (["java.time.MonthDay"]))} (^java.lang.Integer [^java.time.MonthDay this7988] (.getDayOfMonth this7988)))
(clojure.core/defn from {:arglists (quote (["java.time.temporal.TemporalAccessor"]))} (^java.time.MonthDay [^java.time.temporal.TemporalAccessor java-time-temporal-TemporalAccessor7989] (java.time.MonthDay/from java-time-temporal-TemporalAccessor7989)))
(clojure.core/defn is-after {:arglists (quote (["java.time.MonthDay" "java.time.MonthDay"]))} (^java.lang.Boolean [^java.time.MonthDay this7990 ^java.time.MonthDay java-time-MonthDay7991] (.isAfter this7990 java-time-MonthDay7991)))
(clojure.core/defn is-supported {:arglists (quote (["java.time.MonthDay" "java.time.temporal.TemporalField"]))} (^java.lang.Boolean [^java.time.MonthDay this7992 ^java.time.temporal.TemporalField java-time-temporal-TemporalField7993] (.isSupported this7992 java-time-temporal-TemporalField7993)))
(clojure.core/defn parse {:arglists (quote (["java.lang.CharSequence" "java.time.format.DateTimeFormatter"] ["java.lang.CharSequence"]))} (^java.time.MonthDay [^java.lang.CharSequence java-lang-CharSequence7994 ^java.time.format.DateTimeFormatter java-time-format-DateTimeFormatter7995] (java.time.MonthDay/parse java-lang-CharSequence7994 java-time-format-DateTimeFormatter7995)) (^java.time.MonthDay [^java.lang.CharSequence java-lang-CharSequence7996] (java.time.MonthDay/parse java-lang-CharSequence7996)))
(clojure.core/defn is-valid-year {:arglists (quote (["java.time.MonthDay" "int"]))} (^java.lang.Boolean [^java.time.MonthDay this7997 ^java.lang.Integer int7998] (.isValidYear this7997 int7998)))
(clojure.core/defn hash-code {:arglists (quote (["java.time.MonthDay"]))} (^java.lang.Integer [^java.time.MonthDay this7999] (.hashCode this7999)))
(clojure.core/defn adjust-into {:arglists (quote (["java.time.MonthDay" "java.time.temporal.Temporal"]))} (^java.time.temporal.Temporal [^java.time.MonthDay this8000 ^java.time.temporal.Temporal java-time-temporal-Temporal8001] (.adjustInto this8000 java-time-temporal-Temporal8001)))
(clojure.core/defn with {:arglists (quote (["java.time.MonthDay" "java.time.Month"]))} (^java.time.MonthDay [^java.time.MonthDay this8002 ^java.time.Month java-time-Month8003] (.with this8002 java-time-Month8003)))
(clojure.core/defn now {:arglists (quote ([] ["java.time.Clock"] ["java.time.ZoneId"]))} (^java.time.MonthDay [] (java.time.MonthDay/now)) (^java.time.MonthDay [G__8005] (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.Clock") G__8005)) (clojure.core/let [G__8005 ^"java.time.Clock" G__8005] (java.time.MonthDay/now G__8005)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.ZoneId") G__8005)) (clojure.core/let [G__8005 ^"java.time.ZoneId" G__8005] (java.time.MonthDay/now G__8005)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args")))))
(clojure.core/defn get-month-value {:arglists (quote (["java.time.MonthDay"]))} (^java.lang.Integer [^java.time.MonthDay this8006] (.getMonthValue this8006)))
(clojure.core/defn compare-to {:arglists (quote (["java.time.MonthDay" "java.lang.Object"] ["java.time.MonthDay" "java.time.MonthDay"]))} (^java.lang.Integer [this8007 G__8008] (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.lang.Object") G__8008)) (clojure.core/let [G__8008 ^"java.lang.Object" G__8008] (.compareTo ^java.time.MonthDay this8007 G__8008)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.MonthDay") G__8008)) (clojure.core/let [G__8008 ^"java.time.MonthDay" G__8008] (.compareTo ^java.time.MonthDay this8007 G__8008)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args")))))
(clojure.core/defn get-month {:arglists (quote (["java.time.MonthDay"]))} (^java.time.Month [^java.time.MonthDay this8009] (.getMonth this8009)))
(clojure.core/defn get {:arglists (quote (["java.time.MonthDay" "java.time.temporal.TemporalField"]))} (^java.lang.Integer [^java.time.MonthDay this8010 ^java.time.temporal.TemporalField java-time-temporal-TemporalField8011] (.get this8010 java-time-temporal-TemporalField8011)))
(clojure.core/defn equals {:arglists (quote (["java.time.MonthDay" "java.lang.Object"]))} (^java.lang.Boolean [^java.time.MonthDay this8012 ^java.lang.Object java-lang-Object8013] (.equals this8012 java-lang-Object8013)))
(clojure.core/defn format {:arglists (quote (["java.time.MonthDay" "java.time.format.DateTimeFormatter"]))} (^java.lang.String [^java.time.MonthDay this8014 ^java.time.format.DateTimeFormatter java-time-format-DateTimeFormatter8015] (.format this8014 java-time-format-DateTimeFormatter8015)))
