(ns cljc.java-time.local-date-time (:refer-clojure :exclude [get range format min max next name resolve short]) (:require [cljc.java-time.extn.calendar-awareness]) (:import [java.time LocalDateTime]))
(def max java.time.LocalDateTime/MAX)
(def min java.time.LocalDateTime/MIN)
(clojure.core/defn minus-minutes {:arglists (quote (["java.time.LocalDateTime" "long"]))} (^java.time.LocalDateTime [^java.time.LocalDateTime this6358 ^long long6359] (.minusMinutes this6358 long6359)))
(clojure.core/defn truncated-to {:arglists (quote (["java.time.LocalDateTime" "java.time.temporal.TemporalUnit"]))} (^java.time.LocalDateTime [^java.time.LocalDateTime this6360 ^java.time.temporal.TemporalUnit java-time-temporal-TemporalUnit6361] (.truncatedTo this6360 java-time-temporal-TemporalUnit6361)))
(clojure.core/defn minus-weeks {:arglists (quote (["java.time.LocalDateTime" "long"]))} (^java.time.LocalDateTime [^java.time.LocalDateTime this6362 ^long long6363] (.minusWeeks this6362 long6363)))
(clojure.core/defn to-instant {:arglists (quote (["java.time.LocalDateTime" "java.time.ZoneOffset"]))} (^java.time.Instant [^java.time.LocalDateTime this6364 ^java.time.ZoneOffset java-time-ZoneOffset6365] (.toInstant this6364 java-time-ZoneOffset6365)))
(clojure.core/defn plus-weeks {:arglists (quote (["java.time.LocalDateTime" "long"]))} (^java.time.LocalDateTime [^java.time.LocalDateTime this6366 ^long long6367] (.plusWeeks this6366 long6367)))
(clojure.core/defn range {:arglists (quote (["java.time.LocalDateTime" "java.time.temporal.TemporalField"]))} (^java.time.temporal.ValueRange [^java.time.LocalDateTime this6368 ^java.time.temporal.TemporalField java-time-temporal-TemporalField6369] (.range this6368 java-time-temporal-TemporalField6369)))
(clojure.core/defn of-epoch-second {:arglists (quote (["long" "int" "java.time.ZoneOffset"]))} (^java.time.LocalDateTime [^long long6370 ^java.lang.Integer int6371 ^java.time.ZoneOffset java-time-ZoneOffset6372] (java.time.LocalDateTime/ofEpochSecond long6370 int6371 java-time-ZoneOffset6372)))
(clojure.core/defn get-hour {:arglists (quote (["java.time.LocalDateTime"]))} (^java.lang.Integer [^java.time.LocalDateTime this6373] (.getHour this6373)))
(clojure.core/defn at-offset {:arglists (quote (["java.time.LocalDateTime" "java.time.ZoneOffset"]))} (^java.time.OffsetDateTime [^java.time.LocalDateTime this6374 ^java.time.ZoneOffset java-time-ZoneOffset6375] (.atOffset this6374 java-time-ZoneOffset6375)))
(clojure.core/defn minus-hours {:arglists (quote (["java.time.LocalDateTime" "long"]))} (^java.time.LocalDateTime [^java.time.LocalDateTime this6376 ^long long6377] (.minusHours this6376 long6377)))
(clojure.core/defn of {:arglists (quote (["int" "int" "int" "int" "int" "int"] ["int" "java.time.Month" "int" "int" "int"] ["int" "int" "int" "int" "int" "int" "int"] ["java.time.LocalDate" "java.time.LocalTime"] ["int" "java.time.Month" "int" "int" "int" "int" "int"] ["int" "java.time.Month" "int" "int" "int" "int"] ["int" "int" "int" "int" "int"]))} (^java.time.LocalDateTime [G__6379 G__6380 G__6381 G__6382 G__6383 G__6384] (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.lang.Number") G__6379) (clojure.core/instance? (java.lang.Class/forName "java.lang.Number") G__6380) (clojure.core/instance? (java.lang.Class/forName "java.lang.Number") G__6381) (clojure.core/instance? (java.lang.Class/forName "java.lang.Number") G__6382) (clojure.core/instance? (java.lang.Class/forName "java.lang.Number") G__6383) (clojure.core/instance? (java.lang.Class/forName "java.lang.Number") G__6384)) (clojure.core/let [G__6379 (clojure.core/int G__6379) G__6380 (clojure.core/int G__6380) G__6381 (clojure.core/int G__6381) G__6382 (clojure.core/int G__6382) G__6383 (clojure.core/int G__6383) G__6384 (clojure.core/int G__6384)] (java.time.LocalDateTime/of G__6379 G__6380 G__6381 G__6382 G__6383 G__6384)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.lang.Number") G__6379) (clojure.core/instance? (java.lang.Class/forName "java.time.Month") G__6380) (clojure.core/instance? (java.lang.Class/forName "java.lang.Number") G__6381) (clojure.core/instance? (java.lang.Class/forName "java.lang.Number") G__6382) (clojure.core/instance? (java.lang.Class/forName "java.lang.Number") G__6383) (clojure.core/instance? (java.lang.Class/forName "java.lang.Number") G__6384)) (clojure.core/let [G__6379 (clojure.core/int G__6379) G__6380 ^"java.time.Month" G__6380 G__6381 (clojure.core/int G__6381) G__6382 (clojure.core/int G__6382) G__6383 (clojure.core/int G__6383) G__6384 (clojure.core/int G__6384)] (java.time.LocalDateTime/of G__6379 G__6380 G__6381 G__6382 G__6383 G__6384)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args")))) (^java.time.LocalDateTime [G__6386 G__6387 G__6388 G__6389 G__6390] (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.lang.Number") G__6386) (clojure.core/instance? (java.lang.Class/forName "java.time.Month") G__6387) (clojure.core/instance? (java.lang.Class/forName "java.lang.Number") G__6388) (clojure.core/instance? (java.lang.Class/forName "java.lang.Number") G__6389) (clojure.core/instance? (java.lang.Class/forName "java.lang.Number") G__6390)) (clojure.core/let [G__6386 (clojure.core/int G__6386) G__6387 ^"java.time.Month" G__6387 G__6388 (clojure.core/int G__6388) G__6389 (clojure.core/int G__6389) G__6390 (clojure.core/int G__6390)] (java.time.LocalDateTime/of G__6386 G__6387 G__6388 G__6389 G__6390)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.lang.Number") G__6386) (clojure.core/instance? (java.lang.Class/forName "java.lang.Number") G__6387) (clojure.core/instance? (java.lang.Class/forName "java.lang.Number") G__6388) (clojure.core/instance? (java.lang.Class/forName "java.lang.Number") G__6389) (clojure.core/instance? (java.lang.Class/forName "java.lang.Number") G__6390)) (clojure.core/let [G__6386 (clojure.core/int G__6386) G__6387 (clojure.core/int G__6387) G__6388 (clojure.core/int G__6388) G__6389 (clojure.core/int G__6389) G__6390 (clojure.core/int G__6390)] (java.time.LocalDateTime/of G__6386 G__6387 G__6388 G__6389 G__6390)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args")))) (^java.time.LocalDateTime [G__6392 G__6393 G__6394 G__6395 G__6396 G__6397 G__6398] (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.lang.Number") G__6392) (clojure.core/instance? (java.lang.Class/forName "java.lang.Number") G__6393) (clojure.core/instance? (java.lang.Class/forName "java.lang.Number") G__6394) (clojure.core/instance? (java.lang.Class/forName "java.lang.Number") G__6395) (clojure.core/instance? (java.lang.Class/forName "java.lang.Number") G__6396) (clojure.core/instance? (java.lang.Class/forName "java.lang.Number") G__6397) (clojure.core/instance? (java.lang.Class/forName "java.lang.Number") G__6398)) (clojure.core/let [G__6392 (clojure.core/int G__6392) G__6393 (clojure.core/int G__6393) G__6394 (clojure.core/int G__6394) G__6395 (clojure.core/int G__6395) G__6396 (clojure.core/int G__6396) G__6397 (clojure.core/int G__6397) G__6398 (clojure.core/int G__6398)] (java.time.LocalDateTime/of G__6392 G__6393 G__6394 G__6395 G__6396 G__6397 G__6398)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.lang.Number") G__6392) (clojure.core/instance? (java.lang.Class/forName "java.time.Month") G__6393) (clojure.core/instance? (java.lang.Class/forName "java.lang.Number") G__6394) (clojure.core/instance? (java.lang.Class/forName "java.lang.Number") G__6395) (clojure.core/instance? (java.lang.Class/forName "java.lang.Number") G__6396) (clojure.core/instance? (java.lang.Class/forName "java.lang.Number") G__6397) (clojure.core/instance? (java.lang.Class/forName "java.lang.Number") G__6398)) (clojure.core/let [G__6392 (clojure.core/int G__6392) G__6393 ^"java.time.Month" G__6393 G__6394 (clojure.core/int G__6394) G__6395 (clojure.core/int G__6395) G__6396 (clojure.core/int G__6396) G__6397 (clojure.core/int G__6397) G__6398 (clojure.core/int G__6398)] (java.time.LocalDateTime/of G__6392 G__6393 G__6394 G__6395 G__6396 G__6397 G__6398)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args")))) (^java.time.LocalDateTime [^java.time.LocalDate java-time-LocalDate6399 ^java.time.LocalTime java-time-LocalTime6400] (java.time.LocalDateTime/of java-time-LocalDate6399 java-time-LocalTime6400)))
(clojure.core/defn with-month {:arglists (quote (["java.time.LocalDateTime" "int"]))} (^java.time.LocalDateTime [^java.time.LocalDateTime this6401 ^java.lang.Integer int6402] (.withMonth this6401 int6402)))
(clojure.core/defn is-equal {:arglists (quote (["java.time.LocalDateTime" "java.time.chrono.ChronoLocalDateTime"]))} (^java.lang.Boolean [^java.time.LocalDateTime this6403 ^java.time.chrono.ChronoLocalDateTime java-time-chrono-ChronoLocalDateTime6404] (.isEqual this6403 java-time-chrono-ChronoLocalDateTime6404)))
(clojure.core/defn get-nano {:arglists (quote (["java.time.LocalDateTime"]))} (^java.lang.Integer [^java.time.LocalDateTime this6405] (.getNano this6405)))
(clojure.core/defn get-year {:arglists (quote (["java.time.LocalDateTime"]))} (^java.lang.Integer [^java.time.LocalDateTime this6406] (.getYear this6406)))
(clojure.core/defn minus-seconds {:arglists (quote (["java.time.LocalDateTime" "long"]))} (^java.time.LocalDateTime [^java.time.LocalDateTime this6407 ^long long6408] (.minusSeconds this6407 long6408)))
(clojure.core/defn get-second {:arglists (quote (["java.time.LocalDateTime"]))} (^java.lang.Integer [^java.time.LocalDateTime this6409] (.getSecond this6409)))
(clojure.core/defn plus-nanos {:arglists (quote (["java.time.LocalDateTime" "long"]))} (^java.time.LocalDateTime [^java.time.LocalDateTime this6410 ^long long6411] (.plusNanos this6410 long6411)))
(clojure.core/defn get-day-of-year {:arglists (quote (["java.time.LocalDateTime"]))} (^java.lang.Integer [^java.time.LocalDateTime this6412] (.getDayOfYear this6412)))
(clojure.core/defn plus {:arglists (quote (["java.time.LocalDateTime" "long" "java.time.temporal.TemporalUnit"] ["java.time.LocalDateTime" "java.time.temporal.TemporalAmount"] ["java.time.LocalDateTime" "long" "java.time.temporal.TemporalUnit"] ["java.time.LocalDateTime" "java.time.temporal.TemporalAmount"] ["java.time.LocalDateTime" "long" "java.time.temporal.TemporalUnit"] ["java.time.LocalDateTime" "java.time.temporal.TemporalAmount"]))} (^java.lang.Object [this6413 G__6414 G__6415] (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.lang.Long") G__6414) (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalUnit") G__6415)) (clojure.core/let [G__6414 (clojure.core/long G__6414) G__6415 ^"java.time.temporal.TemporalUnit" G__6415] (.plus ^java.time.LocalDateTime this6413 G__6414 G__6415)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.lang.Long") G__6414) (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalUnit") G__6415)) (clojure.core/let [G__6414 (clojure.core/long G__6414) G__6415 ^"java.time.temporal.TemporalUnit" G__6415] (.plus ^java.time.LocalDateTime this6413 G__6414 G__6415)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.lang.Long") G__6414) (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalUnit") G__6415)) (clojure.core/let [G__6414 (clojure.core/long G__6414) G__6415 ^"java.time.temporal.TemporalUnit" G__6415] (.plus ^java.time.LocalDateTime this6413 G__6414 G__6415)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args")))) (^java.lang.Object [this6416 G__6417] (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalAmount") G__6417)) (clojure.core/let [G__6417 ^"java.time.temporal.TemporalAmount" G__6417] (.plus ^java.time.LocalDateTime this6416 G__6417)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalAmount") G__6417)) (clojure.core/let [G__6417 ^"java.time.temporal.TemporalAmount" G__6417] (.plus ^java.time.LocalDateTime this6416 G__6417)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalAmount") G__6417)) (clojure.core/let [G__6417 ^"java.time.temporal.TemporalAmount" G__6417] (.plus ^java.time.LocalDateTime this6416 G__6417)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args")))))
(clojure.core/defn with-hour {:arglists (quote (["java.time.LocalDateTime" "int"]))} (^java.time.LocalDateTime [^java.time.LocalDateTime this6418 ^java.lang.Integer int6419] (.withHour this6418 int6419)))
(clojure.core/defn with-minute {:arglists (quote (["java.time.LocalDateTime" "int"]))} (^java.time.LocalDateTime [^java.time.LocalDateTime this6420 ^java.lang.Integer int6421] (.withMinute this6420 int6421)))
(clojure.core/defn plus-minutes {:arglists (quote (["java.time.LocalDateTime" "long"]))} (^java.time.LocalDateTime [^java.time.LocalDateTime this6422 ^long long6423] (.plusMinutes this6422 long6423)))
(clojure.core/defn query {:arglists (quote (["java.time.LocalDateTime" "java.time.temporal.TemporalQuery"]))} (^java.lang.Object [^java.time.LocalDateTime this6424 ^java.time.temporal.TemporalQuery java-time-temporal-TemporalQuery6425] (.query this6424 java-time-temporal-TemporalQuery6425)))
(clojure.core/defn get-day-of-week {:arglists (quote (["java.time.LocalDateTime"]))} (^java.time.DayOfWeek [^java.time.LocalDateTime this6426] (.getDayOfWeek this6426)))
(clojure.core/defn to-string {:arglists (quote (["java.time.LocalDateTime"]))} (^java.lang.String [^java.time.LocalDateTime this6427] (.toString this6427)))
(clojure.core/defn plus-months {:arglists (quote (["java.time.LocalDateTime" "long"]))} (^java.time.LocalDateTime [^java.time.LocalDateTime this6428 ^long long6429] (.plusMonths this6428 long6429)))
(clojure.core/defn is-before {:arglists (quote (["java.time.LocalDateTime" "java.time.chrono.ChronoLocalDateTime"]))} (^java.lang.Boolean [^java.time.LocalDateTime this6430 ^java.time.chrono.ChronoLocalDateTime java-time-chrono-ChronoLocalDateTime6431] (.isBefore this6430 java-time-chrono-ChronoLocalDateTime6431)))
(clojure.core/defn minus-months {:arglists (quote (["java.time.LocalDateTime" "long"]))} (^java.time.LocalDateTime [^java.time.LocalDateTime this6432 ^long long6433] (.minusMonths this6432 long6433)))
(clojure.core/defn minus {:arglists (quote (["java.time.LocalDateTime" "long" "java.time.temporal.TemporalUnit"] ["java.time.LocalDateTime" "java.time.temporal.TemporalAmount"] ["java.time.LocalDateTime" "long" "java.time.temporal.TemporalUnit"] ["java.time.LocalDateTime" "long" "java.time.temporal.TemporalUnit"] ["java.time.LocalDateTime" "java.time.temporal.TemporalAmount"] ["java.time.LocalDateTime" "java.time.temporal.TemporalAmount"]))} (^java.lang.Object [this6434 G__6435 G__6436] (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.lang.Long") G__6435) (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalUnit") G__6436)) (clojure.core/let [G__6435 (clojure.core/long G__6435) G__6436 ^"java.time.temporal.TemporalUnit" G__6436] (.minus ^java.time.LocalDateTime this6434 G__6435 G__6436)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.lang.Long") G__6435) (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalUnit") G__6436)) (clojure.core/let [G__6435 (clojure.core/long G__6435) G__6436 ^"java.time.temporal.TemporalUnit" G__6436] (.minus ^java.time.LocalDateTime this6434 G__6435 G__6436)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.lang.Long") G__6435) (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalUnit") G__6436)) (clojure.core/let [G__6435 (clojure.core/long G__6435) G__6436 ^"java.time.temporal.TemporalUnit" G__6436] (.minus ^java.time.LocalDateTime this6434 G__6435 G__6436)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args")))) (^java.lang.Object [this6437 G__6438] (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalAmount") G__6438)) (clojure.core/let [G__6438 ^"java.time.temporal.TemporalAmount" G__6438] (.minus ^java.time.LocalDateTime this6437 G__6438)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalAmount") G__6438)) (clojure.core/let [G__6438 ^"java.time.temporal.TemporalAmount" G__6438] (.minus ^java.time.LocalDateTime this6437 G__6438)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalAmount") G__6438)) (clojure.core/let [G__6438 ^"java.time.temporal.TemporalAmount" G__6438] (.minus ^java.time.LocalDateTime this6437 G__6438)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args")))))
(clojure.core/defn at-zone {:arglists (quote (["java.time.LocalDateTime" "java.time.ZoneId"] ["java.time.LocalDateTime" "java.time.ZoneId"]))} (^java.lang.Object [this6439 G__6440] (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.ZoneId") G__6440)) (clojure.core/let [G__6440 ^"java.time.ZoneId" G__6440] (.atZone ^java.time.LocalDateTime this6439 G__6440)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.ZoneId") G__6440)) (clojure.core/let [G__6440 ^"java.time.ZoneId" G__6440] (.atZone ^java.time.LocalDateTime this6439 G__6440)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args")))))
(clojure.core/defn plus-hours {:arglists (quote (["java.time.LocalDateTime" "long"]))} (^java.time.LocalDateTime [^java.time.LocalDateTime this6441 ^long long6442] (.plusHours this6441 long6442)))
(clojure.core/defn plus-days {:arglists (quote (["java.time.LocalDateTime" "long"]))} (^java.time.LocalDateTime [^java.time.LocalDateTime this6443 ^long long6444] (.plusDays this6443 long6444)))
(clojure.core/defn to-local-time {:arglists (quote (["java.time.LocalDateTime"]))} (^java.time.LocalTime [^java.time.LocalDateTime this6445] (.toLocalTime this6445)))
(clojure.core/defn get-long {:arglists (quote (["java.time.LocalDateTime" "java.time.temporal.TemporalField"]))} (^long [^java.time.LocalDateTime this6446 ^java.time.temporal.TemporalField java-time-temporal-TemporalField6447] (.getLong this6446 java-time-temporal-TemporalField6447)))
(clojure.core/defn with-year {:arglists (quote (["java.time.LocalDateTime" "int"]))} (^java.time.LocalDateTime [^java.time.LocalDateTime this6448 ^java.lang.Integer int6449] (.withYear this6448 int6449)))
(clojure.core/defn with-nano {:arglists (quote (["java.time.LocalDateTime" "int"]))} (^java.time.LocalDateTime [^java.time.LocalDateTime this6450 ^java.lang.Integer int6451] (.withNano this6450 int6451)))
(clojure.core/defn to-epoch-second {:arglists (quote (["java.time.LocalDateTime" "java.time.ZoneOffset"]))} (^long [^java.time.LocalDateTime this6452 ^java.time.ZoneOffset java-time-ZoneOffset6453] (.toEpochSecond this6452 java-time-ZoneOffset6453)))
(clojure.core/defn until {:arglists (quote (["java.time.LocalDateTime" "java.time.temporal.Temporal" "java.time.temporal.TemporalUnit"]))} (^long [^java.time.LocalDateTime this6454 ^java.time.temporal.Temporal java-time-temporal-Temporal6455 ^java.time.temporal.TemporalUnit java-time-temporal-TemporalUnit6456] (.until this6454 java-time-temporal-Temporal6455 java-time-temporal-TemporalUnit6456)))
(clojure.core/defn with-day-of-month {:arglists (quote (["java.time.LocalDateTime" "int"]))} (^java.time.LocalDateTime [^java.time.LocalDateTime this6457 ^java.lang.Integer int6458] (.withDayOfMonth this6457 int6458)))
(clojure.core/defn get-day-of-month {:arglists (quote (["java.time.LocalDateTime"]))} (^java.lang.Integer [^java.time.LocalDateTime this6459] (.getDayOfMonth this6459)))
(clojure.core/defn from {:arglists (quote (["java.time.temporal.TemporalAccessor"]))} (^java.time.LocalDateTime [^java.time.temporal.TemporalAccessor java-time-temporal-TemporalAccessor6460] (java.time.LocalDateTime/from java-time-temporal-TemporalAccessor6460)))
(clojure.core/defn is-after {:arglists (quote (["java.time.LocalDateTime" "java.time.chrono.ChronoLocalDateTime"]))} (^java.lang.Boolean [^java.time.LocalDateTime this6461 ^java.time.chrono.ChronoLocalDateTime java-time-chrono-ChronoLocalDateTime6462] (.isAfter this6461 java-time-chrono-ChronoLocalDateTime6462)))
(clojure.core/defn minus-nanos {:arglists (quote (["java.time.LocalDateTime" "long"]))} (^java.time.LocalDateTime [^java.time.LocalDateTime this6463 ^long long6464] (.minusNanos this6463 long6464)))
(clojure.core/defn is-supported {:arglists (quote (["java.time.LocalDateTime" "java.time.temporal.TemporalUnit"] ["java.time.LocalDateTime" "java.time.temporal.TemporalField"]))} (^java.lang.Boolean [this6465 G__6466] (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalUnit") G__6466)) (clojure.core/let [G__6466 ^"java.time.temporal.TemporalUnit" G__6466] (.isSupported ^java.time.LocalDateTime this6465 G__6466)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalField") G__6466)) (clojure.core/let [G__6466 ^"java.time.temporal.TemporalField" G__6466] (.isSupported ^java.time.LocalDateTime this6465 G__6466)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args")))))
(clojure.core/defn minus-years {:arglists (quote (["java.time.LocalDateTime" "long"]))} (^java.time.LocalDateTime [^java.time.LocalDateTime this6467 ^long long6468] (.minusYears this6467 long6468)))
(clojure.core/defn get-chronology {:arglists (quote (["java.time.LocalDateTime"]))} (^java.time.chrono.Chronology [^java.time.LocalDateTime this6469] (.getChronology this6469)))
(clojure.core/defn parse {:arglists (quote (["java.lang.CharSequence"] ["java.lang.CharSequence" "java.time.format.DateTimeFormatter"]))} (^java.time.LocalDateTime [^java.lang.CharSequence java-lang-CharSequence6470] (java.time.LocalDateTime/parse java-lang-CharSequence6470)) (^java.time.LocalDateTime [^java.lang.CharSequence java-lang-CharSequence6471 ^java.time.format.DateTimeFormatter java-time-format-DateTimeFormatter6472] (java.time.LocalDateTime/parse java-lang-CharSequence6471 java-time-format-DateTimeFormatter6472)))
(clojure.core/defn with-second {:arglists (quote (["java.time.LocalDateTime" "int"]))} (^java.time.LocalDateTime [^java.time.LocalDateTime this6473 ^java.lang.Integer int6474] (.withSecond this6473 int6474)))
(clojure.core/defn to-local-date {:arglists (quote (["java.time.LocalDateTime"] ["java.time.LocalDateTime"]))} (^java.lang.Object [this6475] (clojure.core/cond (clojure.core/and) (clojure.core/let [] (.toLocalDate ^java.time.LocalDateTime this6475)) (clojure.core/and) (clojure.core/let [] (.toLocalDate ^java.time.LocalDateTime this6475)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args")))))
(clojure.core/defn get-minute {:arglists (quote (["java.time.LocalDateTime"]))} (^java.lang.Integer [^java.time.LocalDateTime this6476] (.getMinute this6476)))
(clojure.core/defn hash-code {:arglists (quote (["java.time.LocalDateTime"]))} (^java.lang.Integer [^java.time.LocalDateTime this6477] (.hashCode this6477)))
(clojure.core/defn adjust-into {:arglists (quote (["java.time.LocalDateTime" "java.time.temporal.Temporal"]))} (^java.time.temporal.Temporal [^java.time.LocalDateTime this6478 ^java.time.temporal.Temporal java-time-temporal-Temporal6479] (.adjustInto this6478 java-time-temporal-Temporal6479)))
(clojure.core/defn with {:arglists (quote (["java.time.LocalDateTime" "java.time.temporal.TemporalField" "long"] ["java.time.LocalDateTime" "java.time.temporal.TemporalField" "long"] ["java.time.LocalDateTime" "java.time.temporal.TemporalAdjuster"] ["java.time.LocalDateTime" "java.time.temporal.TemporalAdjuster"] ["java.time.LocalDateTime" "java.time.temporal.TemporalAdjuster"] ["java.time.LocalDateTime" "java.time.temporal.TemporalField" "long"]))} (^java.lang.Object [this6480 G__6481 G__6482] (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalField") G__6481) (clojure.core/instance? (java.lang.Class/forName "java.lang.Long") G__6482)) (clojure.core/let [G__6481 ^"java.time.temporal.TemporalField" G__6481 G__6482 (clojure.core/long G__6482)] (.with ^java.time.LocalDateTime this6480 G__6481 G__6482)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalField") G__6481) (clojure.core/instance? (java.lang.Class/forName "java.lang.Long") G__6482)) (clojure.core/let [G__6481 ^"java.time.temporal.TemporalField" G__6481 G__6482 (clojure.core/long G__6482)] (.with ^java.time.LocalDateTime this6480 G__6481 G__6482)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalField") G__6481) (clojure.core/instance? (java.lang.Class/forName "java.lang.Long") G__6482)) (clojure.core/let [G__6481 ^"java.time.temporal.TemporalField" G__6481 G__6482 (clojure.core/long G__6482)] (.with ^java.time.LocalDateTime this6480 G__6481 G__6482)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args")))) (^java.lang.Object [this6483 G__6484] (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalAdjuster") G__6484)) (clojure.core/let [G__6484 ^"java.time.temporal.TemporalAdjuster" G__6484] (.with ^java.time.LocalDateTime this6483 G__6484)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalAdjuster") G__6484)) (clojure.core/let [G__6484 ^"java.time.temporal.TemporalAdjuster" G__6484] (.with ^java.time.LocalDateTime this6483 G__6484)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalAdjuster") G__6484)) (clojure.core/let [G__6484 ^"java.time.temporal.TemporalAdjuster" G__6484] (.with ^java.time.LocalDateTime this6483 G__6484)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args")))))
(clojure.core/defn now {:arglists (quote (["java.time.Clock"] ["java.time.ZoneId"] []))} (^java.time.LocalDateTime [G__6486] (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.Clock") G__6486)) (clojure.core/let [G__6486 ^"java.time.Clock" G__6486] (java.time.LocalDateTime/now G__6486)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.ZoneId") G__6486)) (clojure.core/let [G__6486 ^"java.time.ZoneId" G__6486] (java.time.LocalDateTime/now G__6486)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args")))) (^java.time.LocalDateTime [] (java.time.LocalDateTime/now)))
(clojure.core/defn get-month-value {:arglists (quote (["java.time.LocalDateTime"]))} (^java.lang.Integer [^java.time.LocalDateTime this6487] (.getMonthValue this6487)))
(clojure.core/defn with-day-of-year {:arglists (quote (["java.time.LocalDateTime" "int"]))} (^java.time.LocalDateTime [^java.time.LocalDateTime this6488 ^java.lang.Integer int6489] (.withDayOfYear this6488 int6489)))
(clojure.core/defn compare-to {:arglists (quote (["java.time.LocalDateTime" "java.lang.Object"] ["java.time.LocalDateTime" "java.time.chrono.ChronoLocalDateTime"]))} (^java.lang.Integer [this6490 G__6491] (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.lang.Object") G__6491)) (clojure.core/let [G__6491 ^"java.lang.Object" G__6491] (.compareTo ^java.time.LocalDateTime this6490 G__6491)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.chrono.ChronoLocalDateTime") G__6491)) (clojure.core/let [G__6491 ^"java.time.chrono.ChronoLocalDateTime" G__6491] (.compareTo ^java.time.LocalDateTime this6490 G__6491)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args")))))
(clojure.core/defn get-month {:arglists (quote (["java.time.LocalDateTime"]))} (^java.time.Month [^java.time.LocalDateTime this6492] (.getMonth this6492)))
(clojure.core/defn of-instant {:arglists (quote (["java.time.Instant" "java.time.ZoneId"]))} (^java.time.LocalDateTime [^java.time.Instant java-time-Instant6493 ^java.time.ZoneId java-time-ZoneId6494] (java.time.LocalDateTime/ofInstant java-time-Instant6493 java-time-ZoneId6494)))
(clojure.core/defn plus-seconds {:arglists (quote (["java.time.LocalDateTime" "long"]))} (^java.time.LocalDateTime [^java.time.LocalDateTime this6495 ^long long6496] (.plusSeconds this6495 long6496)))
(clojure.core/defn get {:arglists (quote (["java.time.LocalDateTime" "java.time.temporal.TemporalField"]))} (^java.lang.Integer [^java.time.LocalDateTime this6497 ^java.time.temporal.TemporalField java-time-temporal-TemporalField6498] (.get this6497 java-time-temporal-TemporalField6498)))
(clojure.core/defn equals {:arglists (quote (["java.time.LocalDateTime" "java.lang.Object"]))} (^java.lang.Boolean [^java.time.LocalDateTime this6499 ^java.lang.Object java-lang-Object6500] (.equals this6499 java-lang-Object6500)))
(clojure.core/defn format {:arglists (quote (["java.time.LocalDateTime" "java.time.format.DateTimeFormatter"]))} (^java.lang.String [^java.time.LocalDateTime this6501 ^java.time.format.DateTimeFormatter java-time-format-DateTimeFormatter6502] (.format this6501 java-time-format-DateTimeFormatter6502)))
(clojure.core/defn plus-years {:arglists (quote (["java.time.LocalDateTime" "long"]))} (^java.time.LocalDateTime [^java.time.LocalDateTime this6503 ^long long6504] (.plusYears this6503 long6504)))
(clojure.core/defn minus-days {:arglists (quote (["java.time.LocalDateTime" "long"]))} (^java.time.LocalDateTime [^java.time.LocalDateTime this6505 ^long long6506] (.minusDays this6505 long6506)))
