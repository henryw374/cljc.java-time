(ns cljc.java-time.local-date-time (:refer-clojure :exclude [get range format min max next name resolve short]) (:require [cljc.java-time.extn.calendar-awareness]) (:import [java.time LocalDateTime]))
(def max java.time.LocalDateTime/MAX)
(def min java.time.LocalDateTime/MIN)
(clojure.core/defn minus-minutes {:arglists (quote (["java.time.LocalDateTime" "long"]))} (^java.time.LocalDateTime [^java.time.LocalDateTime this6378 ^long long6379] (.minusMinutes this6378 long6379)))
(clojure.core/defn truncated-to {:arglists (quote (["java.time.LocalDateTime" "java.time.temporal.TemporalUnit"]))} (^java.time.LocalDateTime [^java.time.LocalDateTime this6380 ^java.time.temporal.TemporalUnit java-time-temporal-TemporalUnit6381] (.truncatedTo this6380 java-time-temporal-TemporalUnit6381)))
(clojure.core/defn minus-weeks {:arglists (quote (["java.time.LocalDateTime" "long"]))} (^java.time.LocalDateTime [^java.time.LocalDateTime this6382 ^long long6383] (.minusWeeks this6382 long6383)))
(clojure.core/defn to-instant {:arglists (quote (["java.time.LocalDateTime" "java.time.ZoneOffset"]))} (^java.time.Instant [^java.time.LocalDateTime this6384 ^java.time.ZoneOffset java-time-ZoneOffset6385] (.toInstant this6384 java-time-ZoneOffset6385)))
(clojure.core/defn plus-weeks {:arglists (quote (["java.time.LocalDateTime" "long"]))} (^java.time.LocalDateTime [^java.time.LocalDateTime this6386 ^long long6387] (.plusWeeks this6386 long6387)))
(clojure.core/defn range {:arglists (quote (["java.time.LocalDateTime" "java.time.temporal.TemporalField"]))} (^java.time.temporal.ValueRange [^java.time.LocalDateTime this6388 ^java.time.temporal.TemporalField java-time-temporal-TemporalField6389] (.range this6388 java-time-temporal-TemporalField6389)))
(clojure.core/defn of-epoch-second {:arglists (quote (["long" "int" "java.time.ZoneOffset"]))} (^java.time.LocalDateTime [^long long6390 ^java.lang.Integer int6391 ^java.time.ZoneOffset java-time-ZoneOffset6392] (java.time.LocalDateTime/ofEpochSecond long6390 int6391 java-time-ZoneOffset6392)))
(clojure.core/defn get-hour {:arglists (quote (["java.time.LocalDateTime"]))} (^java.lang.Integer [^java.time.LocalDateTime this6393] (.getHour this6393)))
(clojure.core/defn at-offset {:arglists (quote (["java.time.LocalDateTime" "java.time.ZoneOffset"]))} (^java.time.OffsetDateTime [^java.time.LocalDateTime this6394 ^java.time.ZoneOffset java-time-ZoneOffset6395] (.atOffset this6394 java-time-ZoneOffset6395)))
(clojure.core/defn minus-hours {:arglists (quote (["java.time.LocalDateTime" "long"]))} (^java.time.LocalDateTime [^java.time.LocalDateTime this6396 ^long long6397] (.minusHours this6396 long6397)))
(clojure.core/defn of {:arglists (quote (["int" "int" "int" "int" "int" "int" "int"] ["java.time.LocalDate" "java.time.LocalTime"] ["int" "int" "int" "int" "int"] ["int" "int" "int" "int" "int" "int"] ["int" "java.time.Month" "int" "int" "int"] ["int" "java.time.Month" "int" "int" "int" "int"] ["int" "java.time.Month" "int" "int" "int" "int" "int"]))} (^java.time.LocalDateTime [G__6399 G__6400 G__6401 G__6402 G__6403 G__6404 G__6405] (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.lang.Number") G__6399) (clojure.core/instance? (java.lang.Class/forName "java.lang.Number") G__6400) (clojure.core/instance? (java.lang.Class/forName "java.lang.Number") G__6401) (clojure.core/instance? (java.lang.Class/forName "java.lang.Number") G__6402) (clojure.core/instance? (java.lang.Class/forName "java.lang.Number") G__6403) (clojure.core/instance? (java.lang.Class/forName "java.lang.Number") G__6404) (clojure.core/instance? (java.lang.Class/forName "java.lang.Number") G__6405)) (clojure.core/let [G__6399 (clojure.core/int G__6399) G__6400 (clojure.core/int G__6400) G__6401 (clojure.core/int G__6401) G__6402 (clojure.core/int G__6402) G__6403 (clojure.core/int G__6403) G__6404 (clojure.core/int G__6404) G__6405 (clojure.core/int G__6405)] (java.time.LocalDateTime/of G__6399 G__6400 G__6401 G__6402 G__6403 G__6404 G__6405)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.lang.Number") G__6399) (clojure.core/instance? (java.lang.Class/forName "java.time.Month") G__6400) (clojure.core/instance? (java.lang.Class/forName "java.lang.Number") G__6401) (clojure.core/instance? (java.lang.Class/forName "java.lang.Number") G__6402) (clojure.core/instance? (java.lang.Class/forName "java.lang.Number") G__6403) (clojure.core/instance? (java.lang.Class/forName "java.lang.Number") G__6404) (clojure.core/instance? (java.lang.Class/forName "java.lang.Number") G__6405)) (clojure.core/let [G__6399 (clojure.core/int G__6399) G__6400 ^"java.time.Month" G__6400 G__6401 (clojure.core/int G__6401) G__6402 (clojure.core/int G__6402) G__6403 (clojure.core/int G__6403) G__6404 (clojure.core/int G__6404) G__6405 (clojure.core/int G__6405)] (java.time.LocalDateTime/of G__6399 G__6400 G__6401 G__6402 G__6403 G__6404 G__6405)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args")))) (^java.time.LocalDateTime [^java.time.LocalDate java-time-LocalDate6406 ^java.time.LocalTime java-time-LocalTime6407] (java.time.LocalDateTime/of java-time-LocalDate6406 java-time-LocalTime6407)) (^java.time.LocalDateTime [G__6409 G__6410 G__6411 G__6412 G__6413] (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.lang.Number") G__6409) (clojure.core/instance? (java.lang.Class/forName "java.lang.Number") G__6410) (clojure.core/instance? (java.lang.Class/forName "java.lang.Number") G__6411) (clojure.core/instance? (java.lang.Class/forName "java.lang.Number") G__6412) (clojure.core/instance? (java.lang.Class/forName "java.lang.Number") G__6413)) (clojure.core/let [G__6409 (clojure.core/int G__6409) G__6410 (clojure.core/int G__6410) G__6411 (clojure.core/int G__6411) G__6412 (clojure.core/int G__6412) G__6413 (clojure.core/int G__6413)] (java.time.LocalDateTime/of G__6409 G__6410 G__6411 G__6412 G__6413)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.lang.Number") G__6409) (clojure.core/instance? (java.lang.Class/forName "java.time.Month") G__6410) (clojure.core/instance? (java.lang.Class/forName "java.lang.Number") G__6411) (clojure.core/instance? (java.lang.Class/forName "java.lang.Number") G__6412) (clojure.core/instance? (java.lang.Class/forName "java.lang.Number") G__6413)) (clojure.core/let [G__6409 (clojure.core/int G__6409) G__6410 ^"java.time.Month" G__6410 G__6411 (clojure.core/int G__6411) G__6412 (clojure.core/int G__6412) G__6413 (clojure.core/int G__6413)] (java.time.LocalDateTime/of G__6409 G__6410 G__6411 G__6412 G__6413)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args")))) (^java.time.LocalDateTime [G__6415 G__6416 G__6417 G__6418 G__6419 G__6420] (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.lang.Number") G__6415) (clojure.core/instance? (java.lang.Class/forName "java.lang.Number") G__6416) (clojure.core/instance? (java.lang.Class/forName "java.lang.Number") G__6417) (clojure.core/instance? (java.lang.Class/forName "java.lang.Number") G__6418) (clojure.core/instance? (java.lang.Class/forName "java.lang.Number") G__6419) (clojure.core/instance? (java.lang.Class/forName "java.lang.Number") G__6420)) (clojure.core/let [G__6415 (clojure.core/int G__6415) G__6416 (clojure.core/int G__6416) G__6417 (clojure.core/int G__6417) G__6418 (clojure.core/int G__6418) G__6419 (clojure.core/int G__6419) G__6420 (clojure.core/int G__6420)] (java.time.LocalDateTime/of G__6415 G__6416 G__6417 G__6418 G__6419 G__6420)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.lang.Number") G__6415) (clojure.core/instance? (java.lang.Class/forName "java.time.Month") G__6416) (clojure.core/instance? (java.lang.Class/forName "java.lang.Number") G__6417) (clojure.core/instance? (java.lang.Class/forName "java.lang.Number") G__6418) (clojure.core/instance? (java.lang.Class/forName "java.lang.Number") G__6419) (clojure.core/instance? (java.lang.Class/forName "java.lang.Number") G__6420)) (clojure.core/let [G__6415 (clojure.core/int G__6415) G__6416 ^"java.time.Month" G__6416 G__6417 (clojure.core/int G__6417) G__6418 (clojure.core/int G__6418) G__6419 (clojure.core/int G__6419) G__6420 (clojure.core/int G__6420)] (java.time.LocalDateTime/of G__6415 G__6416 G__6417 G__6418 G__6419 G__6420)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args")))))
(clojure.core/defn with-month {:arglists (quote (["java.time.LocalDateTime" "int"]))} (^java.time.LocalDateTime [^java.time.LocalDateTime this6421 ^java.lang.Integer int6422] (.withMonth this6421 int6422)))
(clojure.core/defn is-equal {:arglists (quote (["java.time.LocalDateTime" "java.time.chrono.ChronoLocalDateTime"]))} (^java.lang.Boolean [^java.time.LocalDateTime this6423 ^java.time.chrono.ChronoLocalDateTime java-time-chrono-ChronoLocalDateTime6424] (.isEqual this6423 java-time-chrono-ChronoLocalDateTime6424)))
(clojure.core/defn get-nano {:arglists (quote (["java.time.LocalDateTime"]))} (^java.lang.Integer [^java.time.LocalDateTime this6425] (.getNano this6425)))
(clojure.core/defn get-year {:arglists (quote (["java.time.LocalDateTime"]))} (^java.lang.Integer [^java.time.LocalDateTime this6426] (.getYear this6426)))
(clojure.core/defn minus-seconds {:arglists (quote (["java.time.LocalDateTime" "long"]))} (^java.time.LocalDateTime [^java.time.LocalDateTime this6427 ^long long6428] (.minusSeconds this6427 long6428)))
(clojure.core/defn get-second {:arglists (quote (["java.time.LocalDateTime"]))} (^java.lang.Integer [^java.time.LocalDateTime this6429] (.getSecond this6429)))
(clojure.core/defn plus-nanos {:arglists (quote (["java.time.LocalDateTime" "long"]))} (^java.time.LocalDateTime [^java.time.LocalDateTime this6430 ^long long6431] (.plusNanos this6430 long6431)))
(clojure.core/defn get-day-of-year {:arglists (quote (["java.time.LocalDateTime"]))} (^java.lang.Integer [^java.time.LocalDateTime this6432] (.getDayOfYear this6432)))
(clojure.core/defn plus {:arglists (quote (["java.time.LocalDateTime" "java.time.temporal.TemporalAmount"] ["java.time.LocalDateTime" "java.time.temporal.TemporalAmount"] ["java.time.LocalDateTime" "java.time.temporal.TemporalAmount"] ["java.time.LocalDateTime" "long" "java.time.temporal.TemporalUnit"] ["java.time.LocalDateTime" "long" "java.time.temporal.TemporalUnit"] ["java.time.LocalDateTime" "long" "java.time.temporal.TemporalUnit"]))} (^java.lang.Object [this6433 G__6434] (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalAmount") G__6434)) (clojure.core/let [G__6434 ^"java.time.temporal.TemporalAmount" G__6434] (.plus ^java.time.LocalDateTime this6433 G__6434)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalAmount") G__6434)) (clojure.core/let [G__6434 ^"java.time.temporal.TemporalAmount" G__6434] (.plus ^java.time.LocalDateTime this6433 G__6434)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalAmount") G__6434)) (clojure.core/let [G__6434 ^"java.time.temporal.TemporalAmount" G__6434] (.plus ^java.time.LocalDateTime this6433 G__6434)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args")))) (^java.lang.Object [this6435 G__6436 G__6437] (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.lang.Long") G__6436) (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalUnit") G__6437)) (clojure.core/let [G__6436 (clojure.core/long G__6436) G__6437 ^"java.time.temporal.TemporalUnit" G__6437] (.plus ^java.time.LocalDateTime this6435 G__6436 G__6437)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.lang.Long") G__6436) (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalUnit") G__6437)) (clojure.core/let [G__6436 (clojure.core/long G__6436) G__6437 ^"java.time.temporal.TemporalUnit" G__6437] (.plus ^java.time.LocalDateTime this6435 G__6436 G__6437)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.lang.Long") G__6436) (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalUnit") G__6437)) (clojure.core/let [G__6436 (clojure.core/long G__6436) G__6437 ^"java.time.temporal.TemporalUnit" G__6437] (.plus ^java.time.LocalDateTime this6435 G__6436 G__6437)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args")))))
(clojure.core/defn with-hour {:arglists (quote (["java.time.LocalDateTime" "int"]))} (^java.time.LocalDateTime [^java.time.LocalDateTime this6438 ^java.lang.Integer int6439] (.withHour this6438 int6439)))
(clojure.core/defn with-minute {:arglists (quote (["java.time.LocalDateTime" "int"]))} (^java.time.LocalDateTime [^java.time.LocalDateTime this6440 ^java.lang.Integer int6441] (.withMinute this6440 int6441)))
(clojure.core/defn plus-minutes {:arglists (quote (["java.time.LocalDateTime" "long"]))} (^java.time.LocalDateTime [^java.time.LocalDateTime this6442 ^long long6443] (.plusMinutes this6442 long6443)))
(clojure.core/defn query {:arglists (quote (["java.time.LocalDateTime" "java.time.temporal.TemporalQuery"]))} (^java.lang.Object [^java.time.LocalDateTime this6444 ^java.time.temporal.TemporalQuery java-time-temporal-TemporalQuery6445] (.query this6444 java-time-temporal-TemporalQuery6445)))
(clojure.core/defn get-day-of-week {:arglists (quote (["java.time.LocalDateTime"]))} (^java.time.DayOfWeek [^java.time.LocalDateTime this6446] (.getDayOfWeek this6446)))
(clojure.core/defn to-string {:arglists (quote (["java.time.LocalDateTime"]))} (^java.lang.String [^java.time.LocalDateTime this6447] (.toString this6447)))
(clojure.core/defn plus-months {:arglists (quote (["java.time.LocalDateTime" "long"]))} (^java.time.LocalDateTime [^java.time.LocalDateTime this6448 ^long long6449] (.plusMonths this6448 long6449)))
(clojure.core/defn is-before {:arglists (quote (["java.time.LocalDateTime" "java.time.chrono.ChronoLocalDateTime"]))} (^java.lang.Boolean [^java.time.LocalDateTime this6450 ^java.time.chrono.ChronoLocalDateTime java-time-chrono-ChronoLocalDateTime6451] (.isBefore this6450 java-time-chrono-ChronoLocalDateTime6451)))
(clojure.core/defn minus-months {:arglists (quote (["java.time.LocalDateTime" "long"]))} (^java.time.LocalDateTime [^java.time.LocalDateTime this6452 ^long long6453] (.minusMonths this6452 long6453)))
(clojure.core/defn minus {:arglists (quote (["java.time.LocalDateTime" "long" "java.time.temporal.TemporalUnit"] ["java.time.LocalDateTime" "long" "java.time.temporal.TemporalUnit"] ["java.time.LocalDateTime" "long" "java.time.temporal.TemporalUnit"] ["java.time.LocalDateTime" "java.time.temporal.TemporalAmount"] ["java.time.LocalDateTime" "java.time.temporal.TemporalAmount"] ["java.time.LocalDateTime" "java.time.temporal.TemporalAmount"]))} (^java.lang.Object [this6454 G__6455 G__6456] (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.lang.Long") G__6455) (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalUnit") G__6456)) (clojure.core/let [G__6455 (clojure.core/long G__6455) G__6456 ^"java.time.temporal.TemporalUnit" G__6456] (.minus ^java.time.LocalDateTime this6454 G__6455 G__6456)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.lang.Long") G__6455) (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalUnit") G__6456)) (clojure.core/let [G__6455 (clojure.core/long G__6455) G__6456 ^"java.time.temporal.TemporalUnit" G__6456] (.minus ^java.time.LocalDateTime this6454 G__6455 G__6456)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.lang.Long") G__6455) (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalUnit") G__6456)) (clojure.core/let [G__6455 (clojure.core/long G__6455) G__6456 ^"java.time.temporal.TemporalUnit" G__6456] (.minus ^java.time.LocalDateTime this6454 G__6455 G__6456)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args")))) (^java.lang.Object [this6457 G__6458] (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalAmount") G__6458)) (clojure.core/let [G__6458 ^"java.time.temporal.TemporalAmount" G__6458] (.minus ^java.time.LocalDateTime this6457 G__6458)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalAmount") G__6458)) (clojure.core/let [G__6458 ^"java.time.temporal.TemporalAmount" G__6458] (.minus ^java.time.LocalDateTime this6457 G__6458)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalAmount") G__6458)) (clojure.core/let [G__6458 ^"java.time.temporal.TemporalAmount" G__6458] (.minus ^java.time.LocalDateTime this6457 G__6458)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args")))))
(clojure.core/defn at-zone {:arglists (quote (["java.time.LocalDateTime" "java.time.ZoneId"] ["java.time.LocalDateTime" "java.time.ZoneId"]))} (^java.lang.Object [this6459 G__6460] (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.ZoneId") G__6460)) (clojure.core/let [G__6460 ^"java.time.ZoneId" G__6460] (.atZone ^java.time.LocalDateTime this6459 G__6460)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.ZoneId") G__6460)) (clojure.core/let [G__6460 ^"java.time.ZoneId" G__6460] (.atZone ^java.time.LocalDateTime this6459 G__6460)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args")))))
(clojure.core/defn plus-hours {:arglists (quote (["java.time.LocalDateTime" "long"]))} (^java.time.LocalDateTime [^java.time.LocalDateTime this6461 ^long long6462] (.plusHours this6461 long6462)))
(clojure.core/defn plus-days {:arglists (quote (["java.time.LocalDateTime" "long"]))} (^java.time.LocalDateTime [^java.time.LocalDateTime this6463 ^long long6464] (.plusDays this6463 long6464)))
(clojure.core/defn to-local-time {:arglists (quote (["java.time.LocalDateTime"]))} (^java.time.LocalTime [^java.time.LocalDateTime this6465] (.toLocalTime this6465)))
(clojure.core/defn get-long {:arglists (quote (["java.time.LocalDateTime" "java.time.temporal.TemporalField"]))} (^long [^java.time.LocalDateTime this6466 ^java.time.temporal.TemporalField java-time-temporal-TemporalField6467] (.getLong this6466 java-time-temporal-TemporalField6467)))
(clojure.core/defn with-year {:arglists (quote (["java.time.LocalDateTime" "int"]))} (^java.time.LocalDateTime [^java.time.LocalDateTime this6468 ^java.lang.Integer int6469] (.withYear this6468 int6469)))
(clojure.core/defn with-nano {:arglists (quote (["java.time.LocalDateTime" "int"]))} (^java.time.LocalDateTime [^java.time.LocalDateTime this6470 ^java.lang.Integer int6471] (.withNano this6470 int6471)))
(clojure.core/defn to-epoch-second {:arglists (quote (["java.time.LocalDateTime" "java.time.ZoneOffset"]))} (^long [^java.time.LocalDateTime this6472 ^java.time.ZoneOffset java-time-ZoneOffset6473] (.toEpochSecond this6472 java-time-ZoneOffset6473)))
(clojure.core/defn until {:arglists (quote (["java.time.LocalDateTime" "java.time.temporal.Temporal" "java.time.temporal.TemporalUnit"]))} (^long [^java.time.LocalDateTime this6474 ^java.time.temporal.Temporal java-time-temporal-Temporal6475 ^java.time.temporal.TemporalUnit java-time-temporal-TemporalUnit6476] (.until this6474 java-time-temporal-Temporal6475 java-time-temporal-TemporalUnit6476)))
(clojure.core/defn with-day-of-month {:arglists (quote (["java.time.LocalDateTime" "int"]))} (^java.time.LocalDateTime [^java.time.LocalDateTime this6477 ^java.lang.Integer int6478] (.withDayOfMonth this6477 int6478)))
(clojure.core/defn get-day-of-month {:arglists (quote (["java.time.LocalDateTime"]))} (^java.lang.Integer [^java.time.LocalDateTime this6479] (.getDayOfMonth this6479)))
(clojure.core/defn from {:arglists (quote (["java.time.temporal.TemporalAccessor"]))} (^java.time.LocalDateTime [^java.time.temporal.TemporalAccessor java-time-temporal-TemporalAccessor6480] (java.time.LocalDateTime/from java-time-temporal-TemporalAccessor6480)))
(clojure.core/defn is-after {:arglists (quote (["java.time.LocalDateTime" "java.time.chrono.ChronoLocalDateTime"]))} (^java.lang.Boolean [^java.time.LocalDateTime this6481 ^java.time.chrono.ChronoLocalDateTime java-time-chrono-ChronoLocalDateTime6482] (.isAfter this6481 java-time-chrono-ChronoLocalDateTime6482)))
(clojure.core/defn minus-nanos {:arglists (quote (["java.time.LocalDateTime" "long"]))} (^java.time.LocalDateTime [^java.time.LocalDateTime this6483 ^long long6484] (.minusNanos this6483 long6484)))
(clojure.core/defn is-supported {:arglists (quote (["java.time.LocalDateTime" "java.time.temporal.TemporalUnit"] ["java.time.LocalDateTime" "java.time.temporal.TemporalField"]))} (^java.lang.Boolean [this6485 G__6486] (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalUnit") G__6486)) (clojure.core/let [G__6486 ^"java.time.temporal.TemporalUnit" G__6486] (.isSupported ^java.time.LocalDateTime this6485 G__6486)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalField") G__6486)) (clojure.core/let [G__6486 ^"java.time.temporal.TemporalField" G__6486] (.isSupported ^java.time.LocalDateTime this6485 G__6486)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args")))))
(clojure.core/defn minus-years {:arglists (quote (["java.time.LocalDateTime" "long"]))} (^java.time.LocalDateTime [^java.time.LocalDateTime this6487 ^long long6488] (.minusYears this6487 long6488)))
(clojure.core/defn get-chronology {:arglists (quote (["java.time.LocalDateTime"]))} (^java.time.chrono.Chronology [^java.time.LocalDateTime this6489] (.getChronology this6489)))
(clojure.core/defn parse {:arglists (quote (["java.lang.CharSequence" "java.time.format.DateTimeFormatter"] ["java.lang.CharSequence"]))} (^java.time.LocalDateTime [^java.lang.CharSequence java-lang-CharSequence6490 ^java.time.format.DateTimeFormatter java-time-format-DateTimeFormatter6491] (java.time.LocalDateTime/parse java-lang-CharSequence6490 java-time-format-DateTimeFormatter6491)) (^java.time.LocalDateTime [^java.lang.CharSequence java-lang-CharSequence6492] (java.time.LocalDateTime/parse java-lang-CharSequence6492)))
(clojure.core/defn with-second {:arglists (quote (["java.time.LocalDateTime" "int"]))} (^java.time.LocalDateTime [^java.time.LocalDateTime this6493 ^java.lang.Integer int6494] (.withSecond this6493 int6494)))
(clojure.core/defn to-local-date {:arglists (quote (["java.time.LocalDateTime"] ["java.time.LocalDateTime"]))} (^java.lang.Object [this6495] (clojure.core/cond (clojure.core/and) (clojure.core/let [] (.toLocalDate ^java.time.LocalDateTime this6495)) (clojure.core/and) (clojure.core/let [] (.toLocalDate ^java.time.LocalDateTime this6495)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args")))))
(clojure.core/defn get-minute {:arglists (quote (["java.time.LocalDateTime"]))} (^java.lang.Integer [^java.time.LocalDateTime this6496] (.getMinute this6496)))
(clojure.core/defn hash-code {:arglists (quote (["java.time.LocalDateTime"]))} (^java.lang.Integer [^java.time.LocalDateTime this6497] (.hashCode this6497)))
(clojure.core/defn adjust-into {:arglists (quote (["java.time.LocalDateTime" "java.time.temporal.Temporal"]))} (^java.time.temporal.Temporal [^java.time.LocalDateTime this6498 ^java.time.temporal.Temporal java-time-temporal-Temporal6499] (.adjustInto this6498 java-time-temporal-Temporal6499)))
(clojure.core/defn with {:arglists (quote (["java.time.LocalDateTime" "java.time.temporal.TemporalField" "long"] ["java.time.LocalDateTime" "java.time.temporal.TemporalField" "long"] ["java.time.LocalDateTime" "java.time.temporal.TemporalField" "long"] ["java.time.LocalDateTime" "java.time.temporal.TemporalAdjuster"] ["java.time.LocalDateTime" "java.time.temporal.TemporalAdjuster"] ["java.time.LocalDateTime" "java.time.temporal.TemporalAdjuster"]))} (^java.lang.Object [this6500 G__6501 G__6502] (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalField") G__6501) (clojure.core/instance? (java.lang.Class/forName "java.lang.Long") G__6502)) (clojure.core/let [G__6501 ^"java.time.temporal.TemporalField" G__6501 G__6502 (clojure.core/long G__6502)] (.with ^java.time.LocalDateTime this6500 G__6501 G__6502)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalField") G__6501) (clojure.core/instance? (java.lang.Class/forName "java.lang.Long") G__6502)) (clojure.core/let [G__6501 ^"java.time.temporal.TemporalField" G__6501 G__6502 (clojure.core/long G__6502)] (.with ^java.time.LocalDateTime this6500 G__6501 G__6502)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalField") G__6501) (clojure.core/instance? (java.lang.Class/forName "java.lang.Long") G__6502)) (clojure.core/let [G__6501 ^"java.time.temporal.TemporalField" G__6501 G__6502 (clojure.core/long G__6502)] (.with ^java.time.LocalDateTime this6500 G__6501 G__6502)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args")))) (^java.lang.Object [this6503 G__6504] (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalAdjuster") G__6504)) (clojure.core/let [G__6504 ^"java.time.temporal.TemporalAdjuster" G__6504] (.with ^java.time.LocalDateTime this6503 G__6504)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalAdjuster") G__6504)) (clojure.core/let [G__6504 ^"java.time.temporal.TemporalAdjuster" G__6504] (.with ^java.time.LocalDateTime this6503 G__6504)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalAdjuster") G__6504)) (clojure.core/let [G__6504 ^"java.time.temporal.TemporalAdjuster" G__6504] (.with ^java.time.LocalDateTime this6503 G__6504)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args")))))
(clojure.core/defn now {:arglists (quote (["java.time.Clock"] ["java.time.ZoneId"] []))} (^java.time.LocalDateTime [G__6506] (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.Clock") G__6506)) (clojure.core/let [G__6506 ^"java.time.Clock" G__6506] (java.time.LocalDateTime/now G__6506)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.ZoneId") G__6506)) (clojure.core/let [G__6506 ^"java.time.ZoneId" G__6506] (java.time.LocalDateTime/now G__6506)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args")))) (^java.time.LocalDateTime [] (java.time.LocalDateTime/now)))
(clojure.core/defn get-month-value {:arglists (quote (["java.time.LocalDateTime"]))} (^java.lang.Integer [^java.time.LocalDateTime this6507] (.getMonthValue this6507)))
(clojure.core/defn with-day-of-year {:arglists (quote (["java.time.LocalDateTime" "int"]))} (^java.time.LocalDateTime [^java.time.LocalDateTime this6508 ^java.lang.Integer int6509] (.withDayOfYear this6508 int6509)))
(clojure.core/defn compare-to {:arglists (quote (["java.time.LocalDateTime" "java.time.chrono.ChronoLocalDateTime"] ["java.time.LocalDateTime" "java.lang.Object"]))} (^java.lang.Integer [this6510 G__6511] (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.chrono.ChronoLocalDateTime") G__6511)) (clojure.core/let [G__6511 ^"java.time.chrono.ChronoLocalDateTime" G__6511] (.compareTo ^java.time.LocalDateTime this6510 G__6511)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.lang.Object") G__6511)) (clojure.core/let [G__6511 ^"java.lang.Object" G__6511] (.compareTo ^java.time.LocalDateTime this6510 G__6511)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args")))))
(clojure.core/defn get-month {:arglists (quote (["java.time.LocalDateTime"]))} (^java.time.Month [^java.time.LocalDateTime this6512] (.getMonth this6512)))
(clojure.core/defn of-instant {:arglists (quote (["java.time.Instant" "java.time.ZoneId"]))} (^java.time.LocalDateTime [^java.time.Instant java-time-Instant6513 ^java.time.ZoneId java-time-ZoneId6514] (java.time.LocalDateTime/ofInstant java-time-Instant6513 java-time-ZoneId6514)))
(clojure.core/defn plus-seconds {:arglists (quote (["java.time.LocalDateTime" "long"]))} (^java.time.LocalDateTime [^java.time.LocalDateTime this6515 ^long long6516] (.plusSeconds this6515 long6516)))
(clojure.core/defn get {:arglists (quote (["java.time.LocalDateTime" "java.time.temporal.TemporalField"]))} (^java.lang.Integer [^java.time.LocalDateTime this6517 ^java.time.temporal.TemporalField java-time-temporal-TemporalField6518] (.get this6517 java-time-temporal-TemporalField6518)))
(clojure.core/defn equals {:arglists (quote (["java.time.LocalDateTime" "java.lang.Object"]))} (^java.lang.Boolean [^java.time.LocalDateTime this6519 ^java.lang.Object java-lang-Object6520] (.equals this6519 java-lang-Object6520)))
(clojure.core/defn format {:arglists (quote (["java.time.LocalDateTime" "java.time.format.DateTimeFormatter"]))} (^java.lang.String [^java.time.LocalDateTime this6521 ^java.time.format.DateTimeFormatter java-time-format-DateTimeFormatter6522] (.format this6521 java-time-format-DateTimeFormatter6522)))
(clojure.core/defn plus-years {:arglists (quote (["java.time.LocalDateTime" "long"]))} (^java.time.LocalDateTime [^java.time.LocalDateTime this6523 ^long long6524] (.plusYears this6523 long6524)))
(clojure.core/defn minus-days {:arglists (quote (["java.time.LocalDateTime" "long"]))} (^java.time.LocalDateTime [^java.time.LocalDateTime this6525 ^long long6526] (.minusDays this6525 long6526)))
