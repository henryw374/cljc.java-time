(ns cljc.java-time.year (:import [java.time Year]) (:refer-clojure :exclude [get range format min max next name resolve short]))
(def min-value java.time.Year/MIN_VALUE)
(def max-value java.time.Year/MAX_VALUE)
(clojure.core/defn range {:arglists (quote (["java.time.Year" "java.time.temporal.TemporalField"]))} (^java.time.temporal.ValueRange [^java.time.Year this50413 ^java.time.temporal.TemporalField java-time-temporal-TemporalField50414] (.range this50413 java-time-temporal-TemporalField50414)))
(clojure.core/defn of {:arglists (quote (["int"]))} (^java.time.Year [^java.lang.Integer int50415] (. java.time.Year of int50415)))
(clojure.core/defn at-day {:arglists (quote (["java.time.Year" "int"]))} (^java.time.LocalDate [^java.time.Year this50416 ^java.lang.Integer int50417] (.atDay this50416 int50417)))
(clojure.core/defn plus {:arglists (quote (["java.time.Year" "java.time.temporal.TemporalAmount"] ["java.time.Year" "long" "java.time.temporal.TemporalUnit"] ["java.time.Year" "java.time.temporal.TemporalAmount"] ["java.time.Year" "long" "java.time.temporal.TemporalUnit"]))} (^java.lang.Object [this50418 G__50419] (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalAmount") G__50419)) (clojure.core/let [G__50419 ^"java.time.temporal.TemporalAmount" G__50419] (.plus ^java.time.Year this50418 G__50419)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalAmount") G__50419)) (clojure.core/let [G__50419 ^"java.time.temporal.TemporalAmount" G__50419] (.plus ^java.time.Year this50418 G__50419)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args")))) (^java.lang.Object [this50420 G__50421 G__50422] (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.lang.Long") G__50421) (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalUnit") G__50422)) (clojure.core/let [G__50421 (clojure.core/long G__50421) G__50422 ^"java.time.temporal.TemporalUnit" G__50422] (.plus ^java.time.Year this50420 G__50421 G__50422)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.lang.Long") G__50421) (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalUnit") G__50422)) (clojure.core/let [G__50421 (clojure.core/long G__50421) G__50422 ^"java.time.temporal.TemporalUnit" G__50422] (.plus ^java.time.Year this50420 G__50421 G__50422)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args")))))
(clojure.core/defn is-valid-month-day {:arglists (quote (["java.time.Year" "java.time.MonthDay"]))} (^java.lang.Boolean [^java.time.Year this50423 ^java.time.MonthDay java-time-MonthDay50424] (.isValidMonthDay this50423 java-time-MonthDay50424)))
(clojure.core/defn query {:arglists (quote (["java.time.Year" "java.time.temporal.TemporalQuery"]))} (^java.lang.Object [^java.time.Year this50425 ^java.time.temporal.TemporalQuery java-time-temporal-TemporalQuery50426] (.query this50425 java-time-temporal-TemporalQuery50426)))
^{:line 77, :column 16} (clojure.core/defn is-leap {:arglists ^{:line 77, :column 54} (quote ^{:line 77, :column 61} (["long"]))} ^{:line 78, :column 18} (^java.lang.Boolean [^long long57050] ^{:line 78, :column 56} (. java.time.Year isLeap long57050)))
(clojure.core/defn to-string {:arglists (quote (["java.time.Year"]))} (^java.lang.String [^java.time.Year this50427] (.toString this50427)))
(clojure.core/defn is-before {:arglists (quote (["java.time.Year" "java.time.Year"]))} (^java.lang.Boolean [^java.time.Year this50428 ^java.time.Year java-time-Year50429] (.isBefore this50428 java-time-Year50429)))
(clojure.core/defn minus {:arglists (quote (["java.time.Year" "java.time.temporal.TemporalAmount"] ["java.time.Year" "java.time.temporal.TemporalAmount"] ["java.time.Year" "long" "java.time.temporal.TemporalUnit"] ["java.time.Year" "long" "java.time.temporal.TemporalUnit"]))} (^java.lang.Object [this50430 G__50431] (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalAmount") G__50431)) (clojure.core/let [G__50431 ^"java.time.temporal.TemporalAmount" G__50431] (.minus ^java.time.Year this50430 G__50431)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalAmount") G__50431)) (clojure.core/let [G__50431 ^"java.time.temporal.TemporalAmount" G__50431] (.minus ^java.time.Year this50430 G__50431)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args")))) (^java.lang.Object [this50432 G__50433 G__50434] (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.lang.Long") G__50433) (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalUnit") G__50434)) (clojure.core/let [G__50433 (clojure.core/long G__50433) G__50434 ^"java.time.temporal.TemporalUnit" G__50434] (.minus ^java.time.Year this50432 G__50433 G__50434)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.lang.Long") G__50433) (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalUnit") G__50434)) (clojure.core/let [G__50433 (clojure.core/long G__50433) G__50434 ^"java.time.temporal.TemporalUnit" G__50434] (.minus ^java.time.Year this50432 G__50433 G__50434)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args")))))
(clojure.core/defn at-month-day {:arglists (quote (["java.time.Year" "java.time.MonthDay"]))} (^java.time.LocalDate [^java.time.Year this50435 ^java.time.MonthDay java-time-MonthDay50436] (.atMonthDay this50435 java-time-MonthDay50436)))
(clojure.core/defn get-value {:arglists (quote (["java.time.Year"]))} (^java.lang.Integer [^java.time.Year this50437] (.getValue this50437)))
(clojure.core/defn get-long {:arglists (quote (["java.time.Year" "java.time.temporal.TemporalField"]))} (^long [^java.time.Year this50438 ^java.time.temporal.TemporalField java-time-temporal-TemporalField50439] (.getLong this50438 java-time-temporal-TemporalField50439)))
(clojure.core/defn at-month {:arglists (quote (["java.time.Year" "int"] ["java.time.Year" "java.time.Month"]))} (^java.time.YearMonth [this50440 G__50441] (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.lang.Number") G__50441)) (clojure.core/let [G__50441 (clojure.core/int G__50441)] (.atMonth ^java.time.Year this50440 G__50441)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.Month") G__50441)) (clojure.core/let [G__50441 ^"java.time.Month" G__50441] (.atMonth ^java.time.Year this50440 G__50441)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args")))))
(clojure.core/defn until {:arglists (quote (["java.time.Year" "java.time.temporal.Temporal" "java.time.temporal.TemporalUnit"]))} (^long [^java.time.Year this50442 ^java.time.temporal.Temporal java-time-temporal-Temporal50443 ^java.time.temporal.TemporalUnit java-time-temporal-TemporalUnit50444] (.until this50442 java-time-temporal-Temporal50443 java-time-temporal-TemporalUnit50444)))
(clojure.core/defn length {:arglists (quote (["java.time.Year"]))} (^java.lang.Integer [^java.time.Year this50445] (.length this50445)))
(clojure.core/defn from {:arglists (quote (["java.time.temporal.TemporalAccessor"]))} (^java.time.Year [^java.time.temporal.TemporalAccessor java-time-temporal-TemporalAccessor50446] (. java.time.Year from java-time-temporal-TemporalAccessor50446)))
(clojure.core/defn is-after {:arglists (quote (["java.time.Year" "java.time.Year"]))} (^java.lang.Boolean [^java.time.Year this50447 ^java.time.Year java-time-Year50448] (.isAfter this50447 java-time-Year50448)))
(clojure.core/defn is-supported {:arglists (quote (["java.time.Year" "java.time.temporal.TemporalField"] ["java.time.Year" "java.time.temporal.TemporalUnit"]))} (^java.lang.Boolean [this50449 G__50450] (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalField") G__50450)) (clojure.core/let [G__50450 ^"java.time.temporal.TemporalField" G__50450] (.isSupported ^java.time.Year this50449 G__50450)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalUnit") G__50450)) (clojure.core/let [G__50450 ^"java.time.temporal.TemporalUnit" G__50450] (.isSupported ^java.time.Year this50449 G__50450)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args")))))
(clojure.core/defn minus-years {:arglists (quote (["java.time.Year" "long"]))} (^java.time.Year [^java.time.Year this50451 ^long long50452] (.minusYears this50451 long50452)))
(clojure.core/defn parse {:arglists (quote (["java.lang.CharSequence" "java.time.format.DateTimeFormatter"] ["java.lang.CharSequence"]))} (^java.time.Year [^java.lang.CharSequence java-lang-CharSequence50453 ^java.time.format.DateTimeFormatter java-time-format-DateTimeFormatter50454] (. java.time.Year parse java-lang-CharSequence50453 java-time-format-DateTimeFormatter50454)) (^java.time.Year [^java.lang.CharSequence java-lang-CharSequence50455] (. java.time.Year parse java-lang-CharSequence50455)))
(clojure.core/defn hash-code {:arglists (quote (["java.time.Year"]))} (^java.lang.Integer [^java.time.Year this50456] (.hashCode this50456)))
(clojure.core/defn adjust-into {:arglists (quote (["java.time.Year" "java.time.temporal.Temporal"]))} (^java.time.temporal.Temporal [^java.time.Year this50457 ^java.time.temporal.Temporal java-time-temporal-Temporal50458] (.adjustInto this50457 java-time-temporal-Temporal50458)))
(clojure.core/defn with {:arglists (quote (["java.time.Year" "java.time.temporal.TemporalField" "long"] ["java.time.Year" "java.time.temporal.TemporalAdjuster"] ["java.time.Year" "java.time.temporal.TemporalAdjuster"] ["java.time.Year" "java.time.temporal.TemporalField" "long"]))} (^java.lang.Object [this50459 G__50460 G__50461] (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalField") G__50460) (clojure.core/instance? (java.lang.Class/forName "java.lang.Long") G__50461)) (clojure.core/let [G__50460 ^"java.time.temporal.TemporalField" G__50460 G__50461 (clojure.core/long G__50461)] (.with ^java.time.Year this50459 G__50460 G__50461)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalField") G__50460) (clojure.core/instance? (java.lang.Class/forName "java.lang.Long") G__50461)) (clojure.core/let [G__50460 ^"java.time.temporal.TemporalField" G__50460 G__50461 (clojure.core/long G__50461)] (.with ^java.time.Year this50459 G__50460 G__50461)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args")))) (^java.lang.Object [this50462 G__50463] (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalAdjuster") G__50463)) (clojure.core/let [G__50463 ^"java.time.temporal.TemporalAdjuster" G__50463] (.with ^java.time.Year this50462 G__50463)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalAdjuster") G__50463)) (clojure.core/let [G__50463 ^"java.time.temporal.TemporalAdjuster" G__50463] (.with ^java.time.Year this50462 G__50463)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args")))))
(clojure.core/defn now {:arglists (quote ([] ["java.time.ZoneId"] ["java.time.Clock"]))} (^java.time.Year [] (. java.time.Year now)) (^java.time.Year [G__50465] (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.ZoneId") G__50465)) (clojure.core/let [G__50465 ^"java.time.ZoneId" G__50465] (. java.time.Year now G__50465)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.Clock") G__50465)) (clojure.core/let [G__50465 ^"java.time.Clock" G__50465] (. java.time.Year now G__50465)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args")))))
(clojure.core/defn compare-to {:arglists (quote (["java.time.Year" "java.time.Year"] ["java.time.Year" "java.lang.Object"]))} (^java.lang.Integer [this50466 G__50467] (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.Year") G__50467)) (clojure.core/let [G__50467 ^"java.time.Year" G__50467] (.compareTo ^java.time.Year this50466 G__50467)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.lang.Object") G__50467)) (clojure.core/let [G__50467 ^"java.lang.Object" G__50467] (.compareTo ^java.time.Year this50466 G__50467)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args")))))
(clojure.core/defn get {:arglists (quote (["java.time.Year" "java.time.temporal.TemporalField"]))} (^java.lang.Integer [^java.time.Year this50468 ^java.time.temporal.TemporalField java-time-temporal-TemporalField50469] (.get this50468 java-time-temporal-TemporalField50469)))
(clojure.core/defn equals {:arglists (quote (["java.time.Year" "java.lang.Object"]))} (^java.lang.Boolean [^java.time.Year this50470 ^java.lang.Object java-lang-Object50471] (.equals this50470 java-lang-Object50471)))
(clojure.core/defn format {:arglists (quote (["java.time.Year" "java.time.format.DateTimeFormatter"]))} (^java.lang.String [^java.time.Year this50472 ^java.time.format.DateTimeFormatter java-time-format-DateTimeFormatter50473] (.format this50472 java-time-format-DateTimeFormatter50473)))
(clojure.core/defn plus-years {:arglists (quote (["java.time.Year" "long"]))} (^java.time.Year [^java.time.Year this50474 ^long long50475] (.plusYears this50474 long50475)))
