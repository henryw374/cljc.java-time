(ns cljc.java-time.year (:refer-clojure :exclude [get range format min max next name resolve short]) (:require [cljc.java-time.extn.calendar-awareness]) (:import [java.time Year]))
(def min-value java.time.Year/MIN_VALUE)
(def max-value java.time.Year/MAX_VALUE)
(clojure.core/defn range {:arglists (quote (["java.time.Year" "java.time.temporal.TemporalField"]))} (^java.time.temporal.ValueRange [^java.time.Year this8240 ^java.time.temporal.TemporalField java-time-temporal-TemporalField8241] (.range this8240 java-time-temporal-TemporalField8241)))
(clojure.core/defn of {:arglists (quote (["int"]))} (^java.time.Year [^java.lang.Integer int8242] (java.time.Year/of int8242)))
(clojure.core/defn at-day {:arglists (quote (["java.time.Year" "int"]))} (^java.time.LocalDate [^java.time.Year this8243 ^java.lang.Integer int8244] (.atDay this8243 int8244)))
(clojure.core/defn plus {:arglists (quote (["java.time.Year" "java.time.temporal.TemporalAmount"] ["java.time.Year" "java.time.temporal.TemporalAmount"] ["java.time.Year" "long" "java.time.temporal.TemporalUnit"] ["java.time.Year" "long" "java.time.temporal.TemporalUnit"]))} (^java.lang.Object [this8245 G__8246] (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalAmount") G__8246)) (clojure.core/let [G__8246 ^"java.time.temporal.TemporalAmount" G__8246] (.plus ^java.time.Year this8245 G__8246)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalAmount") G__8246)) (clojure.core/let [G__8246 ^"java.time.temporal.TemporalAmount" G__8246] (.plus ^java.time.Year this8245 G__8246)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args")))) (^java.lang.Object [this8247 G__8248 G__8249] (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.lang.Long") G__8248) (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalUnit") G__8249)) (clojure.core/let [G__8248 (clojure.core/long G__8248) G__8249 ^"java.time.temporal.TemporalUnit" G__8249] (.plus ^java.time.Year this8247 G__8248 G__8249)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.lang.Long") G__8248) (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalUnit") G__8249)) (clojure.core/let [G__8248 (clojure.core/long G__8248) G__8249 ^"java.time.temporal.TemporalUnit" G__8249] (.plus ^java.time.Year this8247 G__8248 G__8249)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args")))))
(clojure.core/defn is-valid-month-day {:arglists (quote (["java.time.Year" "java.time.MonthDay"]))} (^java.lang.Boolean [^java.time.Year this8250 ^java.time.MonthDay java-time-MonthDay8251] (.isValidMonthDay this8250 java-time-MonthDay8251)))
(clojure.core/defn query {:arglists (quote (["java.time.Year" "java.time.temporal.TemporalQuery"]))} (^java.lang.Object [^java.time.Year this8252 ^java.time.temporal.TemporalQuery java-time-temporal-TemporalQuery8253] (.query this8252 java-time-temporal-TemporalQuery8253)))
^{:line 84, :column 16} (clojure.core/defn is-leap {:arglists ^{:line 84, :column 54} (quote ^{:line 84, :column 61} (["long"]))} ^{:line 85, :column 18} (^java.lang.Boolean [^long long57050] ^{:line 85, :column 56} (. java.time.Year isLeap long57050)))
(clojure.core/defn to-string {:arglists (quote (["java.time.Year"]))} (^java.lang.String [^java.time.Year this8254] (.toString this8254)))
(clojure.core/defn is-before {:arglists (quote (["java.time.Year" "java.time.Year"]))} (^java.lang.Boolean [^java.time.Year this8255 ^java.time.Year java-time-Year8256] (.isBefore this8255 java-time-Year8256)))
(clojure.core/defn minus {:arglists (quote (["java.time.Year" "java.time.temporal.TemporalAmount"] ["java.time.Year" "java.time.temporal.TemporalAmount"] ["java.time.Year" "long" "java.time.temporal.TemporalUnit"] ["java.time.Year" "long" "java.time.temporal.TemporalUnit"]))} (^java.lang.Object [this8257 G__8258] (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalAmount") G__8258)) (clojure.core/let [G__8258 ^"java.time.temporal.TemporalAmount" G__8258] (.minus ^java.time.Year this8257 G__8258)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalAmount") G__8258)) (clojure.core/let [G__8258 ^"java.time.temporal.TemporalAmount" G__8258] (.minus ^java.time.Year this8257 G__8258)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args")))) (^java.lang.Object [this8259 G__8260 G__8261] (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.lang.Long") G__8260) (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalUnit") G__8261)) (clojure.core/let [G__8260 (clojure.core/long G__8260) G__8261 ^"java.time.temporal.TemporalUnit" G__8261] (.minus ^java.time.Year this8259 G__8260 G__8261)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.lang.Long") G__8260) (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalUnit") G__8261)) (clojure.core/let [G__8260 (clojure.core/long G__8260) G__8261 ^"java.time.temporal.TemporalUnit" G__8261] (.minus ^java.time.Year this8259 G__8260 G__8261)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args")))))
(clojure.core/defn at-month-day {:arglists (quote (["java.time.Year" "java.time.MonthDay"]))} (^java.time.LocalDate [^java.time.Year this8262 ^java.time.MonthDay java-time-MonthDay8263] (.atMonthDay this8262 java-time-MonthDay8263)))
(clojure.core/defn get-value {:arglists (quote (["java.time.Year"]))} (^java.lang.Integer [^java.time.Year this8264] (.getValue this8264)))
(clojure.core/defn get-long {:arglists (quote (["java.time.Year" "java.time.temporal.TemporalField"]))} (^long [^java.time.Year this8265 ^java.time.temporal.TemporalField java-time-temporal-TemporalField8266] (.getLong this8265 java-time-temporal-TemporalField8266)))
(clojure.core/defn at-month {:arglists (quote (["java.time.Year" "java.time.Month"] ["java.time.Year" "int"]))} (^java.time.YearMonth [this8267 G__8268] (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.Month") G__8268)) (clojure.core/let [G__8268 ^"java.time.Month" G__8268] (.atMonth ^java.time.Year this8267 G__8268)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.lang.Number") G__8268)) (clojure.core/let [G__8268 (clojure.core/int G__8268)] (.atMonth ^java.time.Year this8267 G__8268)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args")))))
(clojure.core/defn until {:arglists (quote (["java.time.Year" "java.time.temporal.Temporal" "java.time.temporal.TemporalUnit"]))} (^long [^java.time.Year this8269 ^java.time.temporal.Temporal java-time-temporal-Temporal8270 ^java.time.temporal.TemporalUnit java-time-temporal-TemporalUnit8271] (.until this8269 java-time-temporal-Temporal8270 java-time-temporal-TemporalUnit8271)))
(clojure.core/defn length {:arglists (quote (["java.time.Year"]))} (^java.lang.Integer [^java.time.Year this8272] (.length this8272)))
(clojure.core/defn from {:arglists (quote (["java.time.temporal.TemporalAccessor"]))} (^java.time.Year [^java.time.temporal.TemporalAccessor java-time-temporal-TemporalAccessor8273] (java.time.Year/from java-time-temporal-TemporalAccessor8273)))
(clojure.core/defn is-after {:arglists (quote (["java.time.Year" "java.time.Year"]))} (^java.lang.Boolean [^java.time.Year this8274 ^java.time.Year java-time-Year8275] (.isAfter this8274 java-time-Year8275)))
(clojure.core/defn is-supported {:arglists (quote (["java.time.Year" "java.time.temporal.TemporalUnit"] ["java.time.Year" "java.time.temporal.TemporalField"]))} (^java.lang.Boolean [this8276 G__8277] (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalUnit") G__8277)) (clojure.core/let [G__8277 ^"java.time.temporal.TemporalUnit" G__8277] (.isSupported ^java.time.Year this8276 G__8277)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalField") G__8277)) (clojure.core/let [G__8277 ^"java.time.temporal.TemporalField" G__8277] (.isSupported ^java.time.Year this8276 G__8277)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args")))))
(clojure.core/defn minus-years {:arglists (quote (["java.time.Year" "long"]))} (^java.time.Year [^java.time.Year this8278 ^long long8279] (.minusYears this8278 long8279)))
(clojure.core/defn parse {:arglists (quote (["java.lang.CharSequence" "java.time.format.DateTimeFormatter"] ["java.lang.CharSequence"]))} (^java.time.Year [^java.lang.CharSequence java-lang-CharSequence8280 ^java.time.format.DateTimeFormatter java-time-format-DateTimeFormatter8281] (java.time.Year/parse java-lang-CharSequence8280 java-time-format-DateTimeFormatter8281)) (^java.time.Year [^java.lang.CharSequence java-lang-CharSequence8282] (java.time.Year/parse java-lang-CharSequence8282)))
(clojure.core/defn hash-code {:arglists (quote (["java.time.Year"]))} (^java.lang.Integer [^java.time.Year this8283] (.hashCode this8283)))
(clojure.core/defn adjust-into {:arglists (quote (["java.time.Year" "java.time.temporal.Temporal"]))} (^java.time.temporal.Temporal [^java.time.Year this8284 ^java.time.temporal.Temporal java-time-temporal-Temporal8285] (.adjustInto this8284 java-time-temporal-Temporal8285)))
(clojure.core/defn with {:arglists (quote (["java.time.Year" "java.time.temporal.TemporalField" "long"] ["java.time.Year" "java.time.temporal.TemporalField" "long"] ["java.time.Year" "java.time.temporal.TemporalAdjuster"] ["java.time.Year" "java.time.temporal.TemporalAdjuster"]))} (^java.lang.Object [this8286 G__8287 G__8288] (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalField") G__8287) (clojure.core/instance? (java.lang.Class/forName "java.lang.Long") G__8288)) (clojure.core/let [G__8287 ^"java.time.temporal.TemporalField" G__8287 G__8288 (clojure.core/long G__8288)] (.with ^java.time.Year this8286 G__8287 G__8288)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalField") G__8287) (clojure.core/instance? (java.lang.Class/forName "java.lang.Long") G__8288)) (clojure.core/let [G__8287 ^"java.time.temporal.TemporalField" G__8287 G__8288 (clojure.core/long G__8288)] (.with ^java.time.Year this8286 G__8287 G__8288)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args")))) (^java.lang.Object [this8289 G__8290] (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalAdjuster") G__8290)) (clojure.core/let [G__8290 ^"java.time.temporal.TemporalAdjuster" G__8290] (.with ^java.time.Year this8289 G__8290)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalAdjuster") G__8290)) (clojure.core/let [G__8290 ^"java.time.temporal.TemporalAdjuster" G__8290] (.with ^java.time.Year this8289 G__8290)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args")))))
(clojure.core/defn now {:arglists (quote (["java.time.ZoneId"] [] ["java.time.Clock"]))} (^java.time.Year [G__8292] (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.ZoneId") G__8292)) (clojure.core/let [G__8292 ^"java.time.ZoneId" G__8292] (java.time.Year/now G__8292)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.Clock") G__8292)) (clojure.core/let [G__8292 ^"java.time.Clock" G__8292] (java.time.Year/now G__8292)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args")))) (^java.time.Year [] (java.time.Year/now)))
(clojure.core/defn compare-to {:arglists (quote (["java.time.Year" "java.lang.Object"] ["java.time.Year" "java.time.Year"]))} (^java.lang.Integer [this8293 G__8294] (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.lang.Object") G__8294)) (clojure.core/let [G__8294 ^"java.lang.Object" G__8294] (.compareTo ^java.time.Year this8293 G__8294)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.Year") G__8294)) (clojure.core/let [G__8294 ^"java.time.Year" G__8294] (.compareTo ^java.time.Year this8293 G__8294)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args")))))
(clojure.core/defn get {:arglists (quote (["java.time.Year" "java.time.temporal.TemporalField"]))} (^java.lang.Integer [^java.time.Year this8295 ^java.time.temporal.TemporalField java-time-temporal-TemporalField8296] (.get this8295 java-time-temporal-TemporalField8296)))
(clojure.core/defn equals {:arglists (quote (["java.time.Year" "java.lang.Object"]))} (^java.lang.Boolean [^java.time.Year this8297 ^java.lang.Object java-lang-Object8298] (.equals this8297 java-lang-Object8298)))
(clojure.core/defn format {:arglists (quote (["java.time.Year" "java.time.format.DateTimeFormatter"]))} (^java.lang.String [^java.time.Year this8299 ^java.time.format.DateTimeFormatter java-time-format-DateTimeFormatter8300] (.format this8299 java-time-format-DateTimeFormatter8300)))
(clojure.core/defn plus-years {:arglists (quote (["java.time.Year" "long"]))} (^java.time.Year [^java.time.Year this8301 ^long long8302] (.plusYears this8301 long8302)))
