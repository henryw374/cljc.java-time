(ns cljc.java-time.year (:refer-clojure :exclude [get range format min max next name resolve short]) (:require [cljc.java-time.extn.calendar-awareness]) (:import [java.time Year]))
(def min-value java.time.Year/MIN_VALUE)
(def max-value java.time.Year/MAX_VALUE)
(clojure.core/defn range {:arglists (quote (["java.time.Year" "java.time.temporal.TemporalField"]))} (^java.time.temporal.ValueRange [^java.time.Year this8188 ^java.time.temporal.TemporalField java-time-temporal-TemporalField8189] (.range this8188 java-time-temporal-TemporalField8189)))
(clojure.core/defn of {:arglists (quote (["int"]))} (^java.time.Year [^java.lang.Integer int8190] (java.time.Year/of int8190)))
(clojure.core/defn at-day {:arglists (quote (["java.time.Year" "int"]))} (^java.time.LocalDate [^java.time.Year this8191 ^java.lang.Integer int8192] (.atDay this8191 int8192)))
(clojure.core/defn plus {:arglists (quote (["java.time.Year" "java.time.temporal.TemporalAmount"] ["java.time.Year" "java.time.temporal.TemporalAmount"] ["java.time.Year" "long" "java.time.temporal.TemporalUnit"] ["java.time.Year" "long" "java.time.temporal.TemporalUnit"]))} (^java.lang.Object [this8193 G__8194] (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalAmount") G__8194)) (clojure.core/let [G__8194 ^"java.time.temporal.TemporalAmount" G__8194] (.plus ^java.time.Year this8193 G__8194)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalAmount") G__8194)) (clojure.core/let [G__8194 ^"java.time.temporal.TemporalAmount" G__8194] (.plus ^java.time.Year this8193 G__8194)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args")))) (^java.lang.Object [this8195 G__8196 G__8197] (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.lang.Long") G__8196) (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalUnit") G__8197)) (clojure.core/let [G__8196 (clojure.core/long G__8196) G__8197 ^"java.time.temporal.TemporalUnit" G__8197] (.plus ^java.time.Year this8195 G__8196 G__8197)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.lang.Long") G__8196) (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalUnit") G__8197)) (clojure.core/let [G__8196 (clojure.core/long G__8196) G__8197 ^"java.time.temporal.TemporalUnit" G__8197] (.plus ^java.time.Year this8195 G__8196 G__8197)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args")))))
(clojure.core/defn is-valid-month-day {:arglists (quote (["java.time.Year" "java.time.MonthDay"]))} (^java.lang.Boolean [^java.time.Year this8198 ^java.time.MonthDay java-time-MonthDay8199] (.isValidMonthDay this8198 java-time-MonthDay8199)))
(clojure.core/defn query {:arglists (quote (["java.time.Year" "java.time.temporal.TemporalQuery"]))} (^java.lang.Object [^java.time.Year this8200 ^java.time.temporal.TemporalQuery java-time-temporal-TemporalQuery8201] (.query this8200 java-time-temporal-TemporalQuery8201)))
^{:line 84, :column 16} (clojure.core/defn is-leap {:arglists ^{:line 84, :column 54} (quote ^{:line 84, :column 61} (["long"]))} ^{:line 85, :column 18} (^java.lang.Boolean [^long long57050] ^{:line 85, :column 56} (. java.time.Year isLeap long57050)))
(clojure.core/defn to-string {:arglists (quote (["java.time.Year"]))} (^java.lang.String [^java.time.Year this8202] (.toString this8202)))
(clojure.core/defn is-before {:arglists (quote (["java.time.Year" "java.time.Year"]))} (^java.lang.Boolean [^java.time.Year this8203 ^java.time.Year java-time-Year8204] (.isBefore this8203 java-time-Year8204)))
(clojure.core/defn minus {:arglists (quote (["java.time.Year" "long" "java.time.temporal.TemporalUnit"] ["java.time.Year" "long" "java.time.temporal.TemporalUnit"] ["java.time.Year" "java.time.temporal.TemporalAmount"] ["java.time.Year" "java.time.temporal.TemporalAmount"]))} (^java.lang.Object [this8205 G__8206 G__8207] (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.lang.Long") G__8206) (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalUnit") G__8207)) (clojure.core/let [G__8206 (clojure.core/long G__8206) G__8207 ^"java.time.temporal.TemporalUnit" G__8207] (.minus ^java.time.Year this8205 G__8206 G__8207)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.lang.Long") G__8206) (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalUnit") G__8207)) (clojure.core/let [G__8206 (clojure.core/long G__8206) G__8207 ^"java.time.temporal.TemporalUnit" G__8207] (.minus ^java.time.Year this8205 G__8206 G__8207)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args")))) (^java.lang.Object [this8208 G__8209] (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalAmount") G__8209)) (clojure.core/let [G__8209 ^"java.time.temporal.TemporalAmount" G__8209] (.minus ^java.time.Year this8208 G__8209)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalAmount") G__8209)) (clojure.core/let [G__8209 ^"java.time.temporal.TemporalAmount" G__8209] (.minus ^java.time.Year this8208 G__8209)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args")))))
(clojure.core/defn at-month-day {:arglists (quote (["java.time.Year" "java.time.MonthDay"]))} (^java.time.LocalDate [^java.time.Year this8210 ^java.time.MonthDay java-time-MonthDay8211] (.atMonthDay this8210 java-time-MonthDay8211)))
(clojure.core/defn get-value {:arglists (quote (["java.time.Year"]))} (^java.lang.Integer [^java.time.Year this8212] (.getValue this8212)))
(clojure.core/defn get-long {:arglists (quote (["java.time.Year" "java.time.temporal.TemporalField"]))} (^long [^java.time.Year this8213 ^java.time.temporal.TemporalField java-time-temporal-TemporalField8214] (.getLong this8213 java-time-temporal-TemporalField8214)))
(clojure.core/defn at-month {:arglists (quote (["java.time.Year" "int"] ["java.time.Year" "java.time.Month"]))} (^java.time.YearMonth [this8215 G__8216] (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.lang.Number") G__8216)) (clojure.core/let [G__8216 (clojure.core/int G__8216)] (.atMonth ^java.time.Year this8215 G__8216)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.Month") G__8216)) (clojure.core/let [G__8216 ^"java.time.Month" G__8216] (.atMonth ^java.time.Year this8215 G__8216)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args")))))
(clojure.core/defn until {:arglists (quote (["java.time.Year" "java.time.temporal.Temporal" "java.time.temporal.TemporalUnit"]))} (^long [^java.time.Year this8217 ^java.time.temporal.Temporal java-time-temporal-Temporal8218 ^java.time.temporal.TemporalUnit java-time-temporal-TemporalUnit8219] (.until this8217 java-time-temporal-Temporal8218 java-time-temporal-TemporalUnit8219)))
(clojure.core/defn length {:arglists (quote (["java.time.Year"]))} (^java.lang.Integer [^java.time.Year this8220] (.length this8220)))
(clojure.core/defn from {:arglists (quote (["java.time.temporal.TemporalAccessor"]))} (^java.time.Year [^java.time.temporal.TemporalAccessor java-time-temporal-TemporalAccessor8221] (java.time.Year/from java-time-temporal-TemporalAccessor8221)))
(clojure.core/defn is-after {:arglists (quote (["java.time.Year" "java.time.Year"]))} (^java.lang.Boolean [^java.time.Year this8222 ^java.time.Year java-time-Year8223] (.isAfter this8222 java-time-Year8223)))
(clojure.core/defn is-supported {:arglists (quote (["java.time.Year" "java.time.temporal.TemporalUnit"] ["java.time.Year" "java.time.temporal.TemporalField"]))} (^java.lang.Boolean [this8224 G__8225] (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalUnit") G__8225)) (clojure.core/let [G__8225 ^"java.time.temporal.TemporalUnit" G__8225] (.isSupported ^java.time.Year this8224 G__8225)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalField") G__8225)) (clojure.core/let [G__8225 ^"java.time.temporal.TemporalField" G__8225] (.isSupported ^java.time.Year this8224 G__8225)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args")))))
(clojure.core/defn minus-years {:arglists (quote (["java.time.Year" "long"]))} (^java.time.Year [^java.time.Year this8226 ^long long8227] (.minusYears this8226 long8227)))
(clojure.core/defn parse {:arglists (quote (["java.lang.CharSequence" "java.time.format.DateTimeFormatter"] ["java.lang.CharSequence"]))} (^java.time.Year [^java.lang.CharSequence java-lang-CharSequence8228 ^java.time.format.DateTimeFormatter java-time-format-DateTimeFormatter8229] (java.time.Year/parse java-lang-CharSequence8228 java-time-format-DateTimeFormatter8229)) (^java.time.Year [^java.lang.CharSequence java-lang-CharSequence8230] (java.time.Year/parse java-lang-CharSequence8230)))
(clojure.core/defn hash-code {:arglists (quote (["java.time.Year"]))} (^java.lang.Integer [^java.time.Year this8231] (.hashCode this8231)))
(clojure.core/defn adjust-into {:arglists (quote (["java.time.Year" "java.time.temporal.Temporal"]))} (^java.time.temporal.Temporal [^java.time.Year this8232 ^java.time.temporal.Temporal java-time-temporal-Temporal8233] (.adjustInto this8232 java-time-temporal-Temporal8233)))
(clojure.core/defn with {:arglists (quote (["java.time.Year" "java.time.temporal.TemporalField" "long"] ["java.time.Year" "java.time.temporal.TemporalAdjuster"] ["java.time.Year" "java.time.temporal.TemporalField" "long"] ["java.time.Year" "java.time.temporal.TemporalAdjuster"]))} (^java.lang.Object [this8234 G__8235 G__8236] (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalField") G__8235) (clojure.core/instance? (java.lang.Class/forName "java.lang.Long") G__8236)) (clojure.core/let [G__8235 ^"java.time.temporal.TemporalField" G__8235 G__8236 (clojure.core/long G__8236)] (.with ^java.time.Year this8234 G__8235 G__8236)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalField") G__8235) (clojure.core/instance? (java.lang.Class/forName "java.lang.Long") G__8236)) (clojure.core/let [G__8235 ^"java.time.temporal.TemporalField" G__8235 G__8236 (clojure.core/long G__8236)] (.with ^java.time.Year this8234 G__8235 G__8236)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args")))) (^java.lang.Object [this8237 G__8238] (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalAdjuster") G__8238)) (clojure.core/let [G__8238 ^"java.time.temporal.TemporalAdjuster" G__8238] (.with ^java.time.Year this8237 G__8238)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalAdjuster") G__8238)) (clojure.core/let [G__8238 ^"java.time.temporal.TemporalAdjuster" G__8238] (.with ^java.time.Year this8237 G__8238)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args")))))
(clojure.core/defn now {:arglists (quote (["java.time.Clock"] [] ["java.time.ZoneId"]))} (^java.time.Year [G__8240] (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.Clock") G__8240)) (clojure.core/let [G__8240 ^"java.time.Clock" G__8240] (java.time.Year/now G__8240)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.ZoneId") G__8240)) (clojure.core/let [G__8240 ^"java.time.ZoneId" G__8240] (java.time.Year/now G__8240)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args")))) (^java.time.Year [] (java.time.Year/now)))
(clojure.core/defn compare-to {:arglists (quote (["java.time.Year" "java.lang.Object"] ["java.time.Year" "java.time.Year"]))} (^java.lang.Integer [this8241 G__8242] (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.lang.Object") G__8242)) (clojure.core/let [G__8242 ^"java.lang.Object" G__8242] (.compareTo ^java.time.Year this8241 G__8242)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.Year") G__8242)) (clojure.core/let [G__8242 ^"java.time.Year" G__8242] (.compareTo ^java.time.Year this8241 G__8242)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args")))))
(clojure.core/defn get {:arglists (quote (["java.time.Year" "java.time.temporal.TemporalField"]))} (^java.lang.Integer [^java.time.Year this8243 ^java.time.temporal.TemporalField java-time-temporal-TemporalField8244] (.get this8243 java-time-temporal-TemporalField8244)))
(clojure.core/defn equals {:arglists (quote (["java.time.Year" "java.lang.Object"]))} (^java.lang.Boolean [^java.time.Year this8245 ^java.lang.Object java-lang-Object8246] (.equals this8245 java-lang-Object8246)))
(clojure.core/defn format {:arglists (quote (["java.time.Year" "java.time.format.DateTimeFormatter"]))} (^java.lang.String [^java.time.Year this8247 ^java.time.format.DateTimeFormatter java-time-format-DateTimeFormatter8248] (.format this8247 java-time-format-DateTimeFormatter8248)))
(clojure.core/defn plus-years {:arglists (quote (["java.time.Year" "long"]))} (^java.time.Year [^java.time.Year this8249 ^long long8250] (.plusYears this8249 long8250)))
