(ns cljc.java-time.year (:refer-clojure :exclude [get range format min max next name resolve]) (:import [java.time Year]))
(def min-value (. java.time.Year -MIN_VALUE))
(def max-value (. java.time.Year -MAX_VALUE))
(clojure.core/defn range {:arglists (quote (["java.time.Year" "java.time.temporal.TemporalField"]))} (^java.time.temporal.ValueRange [^java.time.Year this7199 ^java.time.temporal.TemporalField java-time-temporal-TemporalField7200] (.range this7199 java-time-temporal-TemporalField7200)))
(clojure.core/defn of {:arglists (quote (["int"]))} (^java.time.Year [^java.lang.Integer int7201] (. java.time.Year of int7201)))
(clojure.core/defn at-day {:arglists (quote (["java.time.Year" "int"]))} (^java.time.LocalDate [^java.time.Year this7202 ^java.lang.Integer int7203] (.atDay this7202 int7203)))
(clojure.core/defn plus {:arglists (quote (["java.time.Year" "long" "java.time.temporal.TemporalUnit"] ["java.time.Year" "long" "java.time.temporal.TemporalUnit"] ["java.time.Year" "java.time.temporal.TemporalAmount"] ["java.time.Year" "java.time.temporal.TemporalAmount"]))} (^java.lang.Object [this7204 G__7205 G__7206] (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.lang.Long") G__7205) (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalUnit") G__7206)) (clojure.core/let [G__7205 (clojure.core/long G__7205) G__7206 ^"java.time.temporal.TemporalUnit" G__7206] (.plus ^java.time.Year this7204 G__7205 G__7206)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.lang.Long") G__7205) (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalUnit") G__7206)) (clojure.core/let [G__7205 (clojure.core/long G__7205) G__7206 ^"java.time.temporal.TemporalUnit" G__7206] (.plus ^java.time.Year this7204 G__7205 G__7206)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args")))) (^java.lang.Object [this7207 G__7208] (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalAmount") G__7208)) (clojure.core/let [G__7208 ^"java.time.temporal.TemporalAmount" G__7208] (.plus ^java.time.Year this7207 G__7208)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalAmount") G__7208)) (clojure.core/let [G__7208 ^"java.time.temporal.TemporalAmount" G__7208] (.plus ^java.time.Year this7207 G__7208)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args")))))
(clojure.core/defn is-valid-month-day {:arglists (quote (["java.time.Year" "java.time.MonthDay"]))} (^java.lang.Boolean [^java.time.Year this7209 ^java.time.MonthDay java-time-MonthDay7210] (.isValidMonthDay this7209 java-time-MonthDay7210)))
(clojure.core/defn query {:arglists (quote (["java.time.Year" "java.time.temporal.TemporalQuery"]))} (^java.lang.Object [^java.time.Year this7211 ^java.time.temporal.TemporalQuery java-time-temporal-TemporalQuery7212] (.query this7211 java-time-temporal-TemporalQuery7212)))
^{:line 72, :column 16} (clojure.core/defn is-leap {:arglists ^{:line 72, :column 54} (quote ^{:line 72, :column 61} (["long"]))} ^{:line 73, :column 18} (^java.lang.Boolean [^long long57050] ^{:line 73, :column 56} (. java.time.Year isLeap long57050)))
(clojure.core/defn to-string {:arglists (quote (["java.time.Year"]))} (^java.lang.String [^java.time.Year this7213] (.toString this7213)))
(clojure.core/defn is-before {:arglists (quote (["java.time.Year" "java.time.Year"]))} (^java.lang.Boolean [^java.time.Year this7214 ^java.time.Year java-time-Year7215] (.isBefore this7214 java-time-Year7215)))
(clojure.core/defn minus {:arglists (quote (["java.time.Year" "long" "java.time.temporal.TemporalUnit"] ["java.time.Year" "java.time.temporal.TemporalAmount"] ["java.time.Year" "java.time.temporal.TemporalAmount"] ["java.time.Year" "long" "java.time.temporal.TemporalUnit"]))} (^java.lang.Object [this7216 G__7217 G__7218] (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.lang.Long") G__7217) (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalUnit") G__7218)) (clojure.core/let [G__7217 (clojure.core/long G__7217) G__7218 ^"java.time.temporal.TemporalUnit" G__7218] (.minus ^java.time.Year this7216 G__7217 G__7218)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.lang.Long") G__7217) (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalUnit") G__7218)) (clojure.core/let [G__7217 (clojure.core/long G__7217) G__7218 ^"java.time.temporal.TemporalUnit" G__7218] (.minus ^java.time.Year this7216 G__7217 G__7218)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args")))) (^java.lang.Object [this7219 G__7220] (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalAmount") G__7220)) (clojure.core/let [G__7220 ^"java.time.temporal.TemporalAmount" G__7220] (.minus ^java.time.Year this7219 G__7220)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalAmount") G__7220)) (clojure.core/let [G__7220 ^"java.time.temporal.TemporalAmount" G__7220] (.minus ^java.time.Year this7219 G__7220)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args")))))
(clojure.core/defn at-month-day {:arglists (quote (["java.time.Year" "java.time.MonthDay"]))} (^java.time.LocalDate [^java.time.Year this7221 ^java.time.MonthDay java-time-MonthDay7222] (.atMonthDay this7221 java-time-MonthDay7222)))
(clojure.core/defn get-value {:arglists (quote (["java.time.Year"]))} (^java.lang.Integer [^java.time.Year this7223] (.getValue this7223)))
(clojure.core/defn get-long {:arglists (quote (["java.time.Year" "java.time.temporal.TemporalField"]))} (^long [^java.time.Year this7224 ^java.time.temporal.TemporalField java-time-temporal-TemporalField7225] (.getLong this7224 java-time-temporal-TemporalField7225)))
(clojure.core/defn at-month {:arglists (quote (["java.time.Year" "int"] ["java.time.Year" "java.time.Month"]))} (^java.time.YearMonth [this7226 G__7227] (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.lang.Number") G__7227)) (clojure.core/let [G__7227 (clojure.core/int G__7227)] (.atMonth ^java.time.Year this7226 G__7227)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.Month") G__7227)) (clojure.core/let [G__7227 ^"java.time.Month" G__7227] (.atMonth ^java.time.Year this7226 G__7227)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args")))))
(clojure.core/defn until {:arglists (quote (["java.time.Year" "java.time.temporal.Temporal" "java.time.temporal.TemporalUnit"]))} (^long [^java.time.Year this7228 ^java.time.temporal.Temporal java-time-temporal-Temporal7229 ^java.time.temporal.TemporalUnit java-time-temporal-TemporalUnit7230] (.until this7228 java-time-temporal-Temporal7229 java-time-temporal-TemporalUnit7230)))
(clojure.core/defn length {:arglists (quote (["java.time.Year"]))} (^java.lang.Integer [^java.time.Year this7231] (.length this7231)))
(clojure.core/defn from {:arglists (quote (["java.time.temporal.TemporalAccessor"]))} (^java.time.Year [^java.time.temporal.TemporalAccessor java-time-temporal-TemporalAccessor7232] (. java.time.Year from java-time-temporal-TemporalAccessor7232)))
(clojure.core/defn is-after {:arglists (quote (["java.time.Year" "java.time.Year"]))} (^java.lang.Boolean [^java.time.Year this7233 ^java.time.Year java-time-Year7234] (.isAfter this7233 java-time-Year7234)))
(clojure.core/defn is-supported {:arglists (quote (["java.time.Year" "java.time.temporal.TemporalField"] ["java.time.Year" "java.time.temporal.TemporalUnit"]))} (^java.lang.Boolean [this7235 G__7236] (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalField") G__7236)) (clojure.core/let [G__7236 ^"java.time.temporal.TemporalField" G__7236] (.isSupported ^java.time.Year this7235 G__7236)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalUnit") G__7236)) (clojure.core/let [G__7236 ^"java.time.temporal.TemporalUnit" G__7236] (.isSupported ^java.time.Year this7235 G__7236)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args")))))
(clojure.core/defn minus-years {:arglists (quote (["java.time.Year" "long"]))} (^java.time.Year [^java.time.Year this7237 ^long long7238] (.minusYears this7237 long7238)))
(clojure.core/defn parse {:arglists (quote (["java.lang.CharSequence" "java.time.format.DateTimeFormatter"] ["java.lang.CharSequence"]))} (^java.time.Year [^java.lang.CharSequence java-lang-CharSequence7239 ^java.time.format.DateTimeFormatter java-time-format-DateTimeFormatter7240] (. java.time.Year parse java-lang-CharSequence7239 java-time-format-DateTimeFormatter7240)) (^java.time.Year [^java.lang.CharSequence java-lang-CharSequence7241] (. java.time.Year parse java-lang-CharSequence7241)))
(clojure.core/defn hash-code {:arglists (quote (["java.time.Year"]))} (^java.lang.Integer [^java.time.Year this7242] (.hashCode this7242)))
(clojure.core/defn adjust-into {:arglists (quote (["java.time.Year" "java.time.temporal.Temporal"]))} (^java.time.temporal.Temporal [^java.time.Year this7243 ^java.time.temporal.Temporal java-time-temporal-Temporal7244] (.adjustInto this7243 java-time-temporal-Temporal7244)))
(clojure.core/defn with {:arglists (quote (["java.time.Year" "java.time.temporal.TemporalField" "long"] ["java.time.Year" "java.time.temporal.TemporalAdjuster"] ["java.time.Year" "java.time.temporal.TemporalField" "long"] ["java.time.Year" "java.time.temporal.TemporalAdjuster"]))} (^java.lang.Object [this7245 G__7246 G__7247] (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalField") G__7246) (clojure.core/instance? (java.lang.Class/forName "java.lang.Long") G__7247)) (clojure.core/let [G__7246 ^"java.time.temporal.TemporalField" G__7246 G__7247 (clojure.core/long G__7247)] (.with ^java.time.Year this7245 G__7246 G__7247)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalField") G__7246) (clojure.core/instance? (java.lang.Class/forName "java.lang.Long") G__7247)) (clojure.core/let [G__7246 ^"java.time.temporal.TemporalField" G__7246 G__7247 (clojure.core/long G__7247)] (.with ^java.time.Year this7245 G__7246 G__7247)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args")))) (^java.lang.Object [this7248 G__7249] (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalAdjuster") G__7249)) (clojure.core/let [G__7249 ^"java.time.temporal.TemporalAdjuster" G__7249] (.with ^java.time.Year this7248 G__7249)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalAdjuster") G__7249)) (clojure.core/let [G__7249 ^"java.time.temporal.TemporalAdjuster" G__7249] (.with ^java.time.Year this7248 G__7249)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args")))))
(clojure.core/defn now {:arglists (quote (["java.time.ZoneId"] ["java.time.Clock"] []))} (^java.time.Year [G__7251] (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.ZoneId") G__7251)) (clojure.core/let [G__7251 ^"java.time.ZoneId" G__7251] (. java.time.Year now G__7251)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.Clock") G__7251)) (clojure.core/let [G__7251 ^"java.time.Clock" G__7251] (. java.time.Year now G__7251)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args")))) (^java.time.Year [] (. java.time.Year now)))
(clojure.core/defn compare-to {:arglists (quote (["java.time.Year" "java.lang.Object"] ["java.time.Year" "java.time.Year"]))} (^java.lang.Integer [this7252 G__7253] (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.lang.Object") G__7253)) (clojure.core/let [G__7253 ^"java.lang.Object" G__7253] (.compareTo ^java.time.Year this7252 G__7253)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.Year") G__7253)) (clojure.core/let [G__7253 ^"java.time.Year" G__7253] (.compareTo ^java.time.Year this7252 G__7253)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args")))))
(clojure.core/defn get {:arglists (quote (["java.time.Year" "java.time.temporal.TemporalField"]))} (^java.lang.Integer [^java.time.Year this7254 ^java.time.temporal.TemporalField java-time-temporal-TemporalField7255] (.get this7254 java-time-temporal-TemporalField7255)))
(clojure.core/defn equals {:arglists (quote (["java.time.Year" "java.lang.Object"]))} (^java.lang.Boolean [^java.time.Year this7256 ^java.lang.Object java-lang-Object7257] (.equals this7256 java-lang-Object7257)))
(clojure.core/defn format {:arglists (quote (["java.time.Year" "java.time.format.DateTimeFormatter"]))} (^java.lang.String [^java.time.Year this7258 ^java.time.format.DateTimeFormatter java-time-format-DateTimeFormatter7259] (.format this7258 java-time-format-DateTimeFormatter7259)))
(clojure.core/defn plus-years {:arglists (quote (["java.time.Year" "long"]))} (^java.time.Year [^java.time.Year this7260 ^long long7261] (.plusYears this7260 long7261)))
