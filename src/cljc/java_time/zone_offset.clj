(ns cljc.java-time.zone-offset (:refer-clojure :exclude [get range format min max next name resolve short]) (:require [cljc.java-time.extn.calendar-awareness]) (:import [java.time ZoneOffset]))
(def max java.time.ZoneOffset/MAX)
(def min java.time.ZoneOffset/MIN)
(def utc java.time.ZoneOffset/UTC)
(clojure.core/defn get-available-zone-ids {:arglists (quote ([]))} (^java.util.Set [] (java.time.ZoneOffset/getAvailableZoneIds)))
(clojure.core/defn range {:arglists (quote (["java.time.ZoneOffset" "java.time.temporal.TemporalField"]))} (^java.time.temporal.ValueRange [^java.time.ZoneOffset this61212 ^java.time.temporal.TemporalField java-time-temporal-TemporalField61213] (.range this61212 java-time-temporal-TemporalField61213)))
(clojure.core/defn of-total-seconds {:arglists (quote (["int"]))} (^java.time.ZoneOffset [^java.lang.Integer int61214] (java.time.ZoneOffset/ofTotalSeconds int61214)))
(clojure.core/defn of {:arglists (quote (["java.lang.String"] ["java.lang.String"] ["java.lang.String" "java.util.Map"]))} (^java.lang.Object [G__61216] (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.lang.String") G__61216)) (clojure.core/let [G__61216 ^"java.lang.String" G__61216] (java.time.ZoneOffset/of G__61216)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.lang.String") G__61216)) (clojure.core/let [G__61216 ^"java.lang.String" G__61216] (java.time.ZoneOffset/of G__61216)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args")))) (^java.time.ZoneId [^java.lang.String java-lang-String61217 ^java.util.Map java-util-Map61218] (java.time.ZoneOffset/of java-lang-String61217 java-util-Map61218)))
(clojure.core/defn of-offset {:arglists (quote (["java.lang.String" "java.time.ZoneOffset"]))} (^java.time.ZoneId [^java.lang.String java-lang-String61219 ^java.time.ZoneOffset java-time-ZoneOffset61220] (java.time.ZoneOffset/ofOffset java-lang-String61219 java-time-ZoneOffset61220)))
(clojure.core/defn query {:arglists (quote (["java.time.ZoneOffset" "java.time.temporal.TemporalQuery"]))} (^java.lang.Object [^java.time.ZoneOffset this61221 ^java.time.temporal.TemporalQuery java-time-temporal-TemporalQuery61222] (.query this61221 java-time-temporal-TemporalQuery61222)))
(clojure.core/defn to-string {:arglists (quote (["java.time.ZoneOffset"]))} (^java.lang.String [^java.time.ZoneOffset this61223] (.toString this61223)))
(clojure.core/defn get-display-name {:arglists (quote (["java.time.ZoneOffset" "java.time.format.TextStyle" "java.util.Locale"]))} (^java.lang.String [^java.time.ZoneOffset this61224 ^java.time.format.TextStyle java-time-format-TextStyle61225 ^java.util.Locale java-util-Locale61226] (.getDisplayName this61224 java-time-format-TextStyle61225 java-util-Locale61226)))
(clojure.core/defn get-long {:arglists (quote (["java.time.ZoneOffset" "java.time.temporal.TemporalField"]))} (^long [^java.time.ZoneOffset this61227 ^java.time.temporal.TemporalField java-time-temporal-TemporalField61228] (.getLong this61227 java-time-temporal-TemporalField61228)))
(clojure.core/defn get-rules {:arglists (quote (["java.time.ZoneOffset"]))} (^java.time.zone.ZoneRules [^java.time.ZoneOffset this61229] (.getRules this61229)))
(clojure.core/defn of-hours {:arglists (quote (["int"]))} (^java.time.ZoneOffset [^java.lang.Integer int61230] (java.time.ZoneOffset/ofHours int61230)))
(clojure.core/defn get-id {:arglists (quote (["java.time.ZoneOffset"]))} (^java.lang.String [^java.time.ZoneOffset this61231] (.getId this61231)))
(clojure.core/defn normalized {:arglists (quote (["java.time.ZoneOffset"]))} (^java.time.ZoneId [^java.time.ZoneOffset this61232] (.normalized this61232)))
(clojure.core/defn system-default {:arglists (quote ([]))} (^java.time.ZoneId [] (java.time.ZoneOffset/systemDefault)))
(clojure.core/defn from {:arglists (quote (["java.time.temporal.TemporalAccessor"] ["java.time.temporal.TemporalAccessor"]))} (^java.lang.Object [G__61234] (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalAccessor") G__61234)) (clojure.core/let [G__61234 ^"java.time.temporal.TemporalAccessor" G__61234] (java.time.ZoneOffset/from G__61234)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalAccessor") G__61234)) (clojure.core/let [G__61234 ^"java.time.temporal.TemporalAccessor" G__61234] (java.time.ZoneOffset/from G__61234)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args")))))
(clojure.core/defn of-hours-minutes-seconds {:arglists (quote (["int" "int" "int"]))} (^java.time.ZoneOffset [^java.lang.Integer int61235 ^java.lang.Integer int61236 ^java.lang.Integer int61237] (java.time.ZoneOffset/ofHoursMinutesSeconds int61235 int61236 int61237)))
(clojure.core/defn is-supported {:arglists (quote (["java.time.ZoneOffset" "java.time.temporal.TemporalField"]))} (^java.lang.Boolean [^java.time.ZoneOffset this61238 ^java.time.temporal.TemporalField java-time-temporal-TemporalField61239] (.isSupported this61238 java-time-temporal-TemporalField61239)))
(clojure.core/defn hash-code {:arglists (quote (["java.time.ZoneOffset"]))} (^java.lang.Integer [^java.time.ZoneOffset this61240] (.hashCode this61240)))
(clojure.core/defn get-total-seconds {:arglists (quote (["java.time.ZoneOffset"]))} (^java.lang.Integer [^java.time.ZoneOffset this61241] (.getTotalSeconds this61241)))
(clojure.core/defn adjust-into {:arglists (quote (["java.time.ZoneOffset" "java.time.temporal.Temporal"]))} (^java.time.temporal.Temporal [^java.time.ZoneOffset this61242 ^java.time.temporal.Temporal java-time-temporal-Temporal61243] (.adjustInto this61242 java-time-temporal-Temporal61243)))
(clojure.core/defn of-hours-minutes {:arglists (quote (["int" "int"]))} (^java.time.ZoneOffset [^java.lang.Integer int61244 ^java.lang.Integer int61245] (java.time.ZoneOffset/ofHoursMinutes int61244 int61245)))
(clojure.core/defn compare-to {:arglists (quote (["java.time.ZoneOffset" "java.time.ZoneOffset"] ["java.time.ZoneOffset" "java.lang.Object"]))} (^java.lang.Integer [this61246 G__61247] (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.ZoneOffset") G__61247)) (clojure.core/let [G__61247 ^"java.time.ZoneOffset" G__61247] (.compareTo ^java.time.ZoneOffset this61246 G__61247)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.lang.Object") G__61247)) (clojure.core/let [G__61247 ^"java.lang.Object" G__61247] (.compareTo ^java.time.ZoneOffset this61246 G__61247)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args")))))
(clojure.core/defn get {:arglists (quote (["java.time.ZoneOffset" "java.time.temporal.TemporalField"]))} (^java.lang.Integer [^java.time.ZoneOffset this61248 ^java.time.temporal.TemporalField java-time-temporal-TemporalField61249] (.get this61248 java-time-temporal-TemporalField61249)))
(clojure.core/defn equals {:arglists (quote (["java.time.ZoneOffset" "java.lang.Object"]))} (^java.lang.Boolean [^java.time.ZoneOffset this61250 ^java.lang.Object java-lang-Object61251] (.equals this61250 java-lang-Object61251)))
