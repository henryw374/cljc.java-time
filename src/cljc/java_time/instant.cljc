(ns cljc.java-time.instant (:require [cljs.java-time.interop :as jti] #? (:cljs [java.time :refer [Instant]])) (:refer-clojure :exclude [get range format min max next name resolve]) #? (:clj (:import [java.time Instant])))
(def min (. java.time.Instant -MIN))
(def epoch (. java.time.Instant -EPOCH))
(def max (. java.time.Instant -MAX))
(clojure.core/defn truncated-to {:arglists (quote (["java.time.Instant" "java.time.temporal.TemporalUnit"]))} (^java.time.Instant [^java.time.Instant this3981 ^java.time.temporal.TemporalUnit java-time-temporal-TemporalUnit3982] (.truncatedTo this3981 java-time-temporal-TemporalUnit3982)))
(clojure.core/defn range {:arglists (quote (["java.time.Instant" "java.time.temporal.TemporalField"]))} (^java.time.temporal.ValueRange [^java.time.Instant this3983 ^java.time.temporal.TemporalField java-time-temporal-TemporalField3984] (.range this3983 java-time-temporal-TemporalField3984)))
(clojure.core/defn of-epoch-second {:arglists (quote (["long"] ["long" "long"]))} (^java.time.Instant [^long long3985] (. java.time.Instant ofEpochSecond long3985)) (^java.time.Instant [^long long3986 ^long long3987] (. java.time.Instant ofEpochSecond long3986 long3987)))
(clojure.core/defn at-offset {:arglists (quote (["java.time.Instant" "java.time.ZoneOffset"]))} (^java.time.OffsetDateTime [^java.time.Instant this3988 ^java.time.ZoneOffset java-time-ZoneOffset3989] (.atOffset this3988 java-time-ZoneOffset3989)))
(clojure.core/defn minus-millis {:arglists (quote (["java.time.Instant" "long"]))} (^java.time.Instant [^java.time.Instant this3990 ^long long3991] (.minusMillis this3990 long3991)))
(clojure.core/defn get-nano {:arglists (quote (["java.time.Instant"]))} (^java.lang.Integer [^java.time.Instant this3992] (jti/getter nano this3992)))
(clojure.core/defn plus-millis {:arglists (quote (["java.time.Instant" "long"]))} (^java.time.Instant [^java.time.Instant this3993 ^long long3994] (.plusMillis this3993 long3994)))
(clojure.core/defn minus-seconds {:arglists (quote (["java.time.Instant" "long"]))} (^java.time.Instant [^java.time.Instant this3995 ^long long3996] (.minusSeconds this3995 long3996)))
(clojure.core/defn plus-nanos {:arglists (quote (["java.time.Instant" "long"]))} (^java.time.Instant [^java.time.Instant this3997 ^long long3998] (.plusNanos this3997 long3998)))
(clojure.core/defn plus {:arglists (quote (["java.time.Instant" "java.time.temporal.TemporalAmount"] ["java.time.Instant" "java.time.temporal.TemporalAmount"] ["java.time.Instant" "long" "java.time.temporal.TemporalUnit"] ["java.time.Instant" "long" "java.time.temporal.TemporalUnit"]))} (^java.lang.Object [this3999 G__4000] #? (:cljs (.plus ^java.time.Instant this3999 G__4000) :clj (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalAmount") G__4000)) (clojure.core/let [G__4000 ^"java.time.temporal.TemporalAmount" G__4000] (.plus ^java.time.Instant this3999 G__4000)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalAmount") G__4000)) (clojure.core/let [G__4000 ^"java.time.temporal.TemporalAmount" G__4000] (.plus ^java.time.Instant this3999 G__4000)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args"))))) (^java.lang.Object [this4001 G__4002 G__4003] #? (:cljs (.plus ^java.time.Instant this4001 G__4002 G__4003) :clj (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.lang.Long") G__4002) (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalUnit") G__4003)) (clojure.core/let [G__4002 (clojure.core/long G__4002) G__4003 ^"java.time.temporal.TemporalUnit" G__4003] (.plus ^java.time.Instant this4001 G__4002 G__4003)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.lang.Long") G__4002) (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalUnit") G__4003)) (clojure.core/let [G__4002 (clojure.core/long G__4002) G__4003 ^"java.time.temporal.TemporalUnit" G__4003] (.plus ^java.time.Instant this4001 G__4002 G__4003)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args"))))))
(clojure.core/defn query {:arglists (quote (["java.time.Instant" "java.time.temporal.TemporalQuery"]))} (^java.lang.Object [^java.time.Instant this4004 ^java.time.temporal.TemporalQuery java-time-temporal-TemporalQuery4005] (.query this4004 java-time-temporal-TemporalQuery4005)))
(clojure.core/defn to-string {:arglists (quote (["java.time.Instant"]))} (^java.lang.String [^java.time.Instant this4006] (.toString this4006)))
(clojure.core/defn is-before {:arglists (quote (["java.time.Instant" "java.time.Instant"]))} (^java.lang.Boolean [^java.time.Instant this4007 ^java.time.Instant java-time-Instant4008] (.isBefore this4007 java-time-Instant4008)))
(clojure.core/defn minus {:arglists (quote (["java.time.Instant" "long" "java.time.temporal.TemporalUnit"] ["java.time.Instant" "java.time.temporal.TemporalAmount"] ["java.time.Instant" "long" "java.time.temporal.TemporalUnit"] ["java.time.Instant" "java.time.temporal.TemporalAmount"]))} (^java.lang.Object [this4009 G__4010 G__4011] #? (:cljs (.minus ^java.time.Instant this4009 G__4010 G__4011) :clj (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.lang.Long") G__4010) (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalUnit") G__4011)) (clojure.core/let [G__4010 (clojure.core/long G__4010) G__4011 ^"java.time.temporal.TemporalUnit" G__4011] (.minus ^java.time.Instant this4009 G__4010 G__4011)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.lang.Long") G__4010) (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalUnit") G__4011)) (clojure.core/let [G__4010 (clojure.core/long G__4010) G__4011 ^"java.time.temporal.TemporalUnit" G__4011] (.minus ^java.time.Instant this4009 G__4010 G__4011)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args"))))) (^java.lang.Object [this4012 G__4013] #? (:cljs (.minus ^java.time.Instant this4012 G__4013) :clj (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalAmount") G__4013)) (clojure.core/let [G__4013 ^"java.time.temporal.TemporalAmount" G__4013] (.minus ^java.time.Instant this4012 G__4013)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalAmount") G__4013)) (clojure.core/let [G__4013 ^"java.time.temporal.TemporalAmount" G__4013] (.minus ^java.time.Instant this4012 G__4013)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args"))))))
(clojure.core/defn at-zone {:arglists (quote (["java.time.Instant" "java.time.ZoneId"]))} (^java.time.ZonedDateTime [^java.time.Instant this4014 ^java.time.ZoneId java-time-ZoneId4015] (.atZone this4014 java-time-ZoneId4015)))
(clojure.core/defn of-epoch-milli {:arglists (quote (["long"]))} (^java.time.Instant [^long long4016] (. java.time.Instant ofEpochMilli long4016)))
(clojure.core/defn get-long {:arglists (quote (["java.time.Instant" "java.time.temporal.TemporalField"]))} (^long [^java.time.Instant this4017 ^java.time.temporal.TemporalField java-time-temporal-TemporalField4018] (.getLong this4017 java-time-temporal-TemporalField4018)))
(clojure.core/defn until {:arglists (quote (["java.time.Instant" "java.time.temporal.Temporal" "java.time.temporal.TemporalUnit"]))} (^long [^java.time.Instant this4019 ^java.time.temporal.Temporal java-time-temporal-Temporal4020 ^java.time.temporal.TemporalUnit java-time-temporal-TemporalUnit4021] (.until this4019 java-time-temporal-Temporal4020 java-time-temporal-TemporalUnit4021)))
(clojure.core/defn from {:arglists (quote (["java.time.temporal.TemporalAccessor"]))} (^java.time.Instant [^java.time.temporal.TemporalAccessor java-time-temporal-TemporalAccessor4022] (. java.time.Instant from java-time-temporal-TemporalAccessor4022)))
(clojure.core/defn is-after {:arglists (quote (["java.time.Instant" "java.time.Instant"]))} (^java.lang.Boolean [^java.time.Instant this4023 ^java.time.Instant java-time-Instant4024] (.isAfter this4023 java-time-Instant4024)))
(clojure.core/defn minus-nanos {:arglists (quote (["java.time.Instant" "long"]))} (^java.time.Instant [^java.time.Instant this4025 ^long long4026] (.minusNanos this4025 long4026)))
(clojure.core/defn is-supported {:arglists (quote (["java.time.Instant" "java.time.temporal.TemporalUnit"] ["java.time.Instant" "java.time.temporal.TemporalField"]))} (^java.lang.Boolean [this4027 G__4028] #? (:cljs (.isSupported ^java.time.Instant this4027 G__4028) :clj (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalUnit") G__4028)) (clojure.core/let [G__4028 ^"java.time.temporal.TemporalUnit" G__4028] (.isSupported ^java.time.Instant this4027 G__4028)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalField") G__4028)) (clojure.core/let [G__4028 ^"java.time.temporal.TemporalField" G__4028] (.isSupported ^java.time.Instant this4027 G__4028)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args"))))))
(clojure.core/defn parse {:arglists (quote (["java.lang.CharSequence"]))} (^java.time.Instant [^java.lang.CharSequence java-lang-CharSequence4029] (. java.time.Instant parse java-lang-CharSequence4029)))
(clojure.core/defn hash-code {:arglists (quote (["java.time.Instant"]))} (^java.lang.Integer [^java.time.Instant this4030] (.hashCode this4030)))
(clojure.core/defn adjust-into {:arglists (quote (["java.time.Instant" "java.time.temporal.Temporal"]))} (^java.time.temporal.Temporal [^java.time.Instant this4031 ^java.time.temporal.Temporal java-time-temporal-Temporal4032] (.adjustInto this4031 java-time-temporal-Temporal4032)))
(clojure.core/defn with {:arglists (quote (["java.time.Instant" "java.time.temporal.TemporalAdjuster"] ["java.time.Instant" "java.time.temporal.TemporalField" "long"] ["java.time.Instant" "java.time.temporal.TemporalAdjuster"] ["java.time.Instant" "java.time.temporal.TemporalField" "long"]))} (^java.lang.Object [this4033 G__4034] #? (:cljs (.with ^java.time.Instant this4033 G__4034) :clj (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalAdjuster") G__4034)) (clojure.core/let [G__4034 ^"java.time.temporal.TemporalAdjuster" G__4034] (.with ^java.time.Instant this4033 G__4034)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalAdjuster") G__4034)) (clojure.core/let [G__4034 ^"java.time.temporal.TemporalAdjuster" G__4034] (.with ^java.time.Instant this4033 G__4034)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args"))))) (^java.lang.Object [this4035 G__4036 G__4037] #? (:cljs (.with ^java.time.Instant this4035 G__4036 G__4037) :clj (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalField") G__4036) (clojure.core/instance? (java.lang.Class/forName "java.lang.Long") G__4037)) (clojure.core/let [G__4036 ^"java.time.temporal.TemporalField" G__4036 G__4037 (clojure.core/long G__4037)] (.with ^java.time.Instant this4035 G__4036 G__4037)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalField") G__4036) (clojure.core/instance? (java.lang.Class/forName "java.lang.Long") G__4037)) (clojure.core/let [G__4036 ^"java.time.temporal.TemporalField" G__4036 G__4037 (clojure.core/long G__4037)] (.with ^java.time.Instant this4035 G__4036 G__4037)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args"))))))
(clojure.core/defn now {:arglists (quote ([] ["java.time.Clock"]))} (^java.time.Instant [] (. java.time.Instant now)) (^java.time.Instant [^java.time.Clock java-time-Clock4038] (. java.time.Instant now java-time-Clock4038)))
(clojure.core/defn to-epoch-milli {:arglists (quote (["java.time.Instant"]))} (^long [^java.time.Instant this4039] (.toEpochMilli this4039)))
(clojure.core/defn get-epoch-second {:arglists (quote (["java.time.Instant"]))} (^long [^java.time.Instant this4040] (jti/getter epochSecond this4040)))
(clojure.core/defn compare-to {:arglists (quote (["java.time.Instant" "java.time.Instant"] ["java.time.Instant" "java.lang.Object"]))} (^java.lang.Integer [this4041 G__4042] #? (:cljs (.compareTo ^java.time.Instant this4041 G__4042) :clj (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.Instant") G__4042)) (clojure.core/let [G__4042 ^"java.time.Instant" G__4042] (.compareTo ^java.time.Instant this4041 G__4042)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.lang.Object") G__4042)) (clojure.core/let [G__4042 ^"java.lang.Object" G__4042] (.compareTo ^java.time.Instant this4041 G__4042)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args"))))))
(clojure.core/defn plus-seconds {:arglists (quote (["java.time.Instant" "long"]))} (^java.time.Instant [^java.time.Instant this4043 ^long long4044] (.plusSeconds this4043 long4044)))
(clojure.core/defn get {:arglists (quote (["java.time.Instant" "java.time.temporal.TemporalField"]))} (^java.lang.Integer [^java.time.Instant this4045 ^java.time.temporal.TemporalField java-time-temporal-TemporalField4046] (.get this4045 java-time-temporal-TemporalField4046)))
(clojure.core/defn equals {:arglists (quote (["java.time.Instant" "java.lang.Object"]))} (^java.lang.Boolean [^java.time.Instant this4047 ^java.lang.Object java-lang-Object4048] (.equals this4047 java-lang-Object4048)))
